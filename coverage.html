
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sbsync: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">storyblok-sync/cmd/sbsync/main.go (0.0%)</option>
				
				<option value="file1">storyblok-sync/internal/config/config.go (89.5%)</option>
				
				<option value="file2">storyblok-sync/internal/sb/client.go (74.6%)</option>
				
				<option value="file3">storyblok-sync/internal/ui/browse_filtering.go (82.7%)</option>
				
				<option value="file4">storyblok-sync/internal/ui/browse_input.go (25.3%)</option>
				
				<option value="file5">storyblok-sync/internal/ui/browse_navigation.go (29.7%)</option>
				
				<option value="file6">storyblok-sync/internal/ui/browse_selection.go (88.9%)</option>
				
				<option value="file7">storyblok-sync/internal/ui/browse_tree.go (83.3%)</option>
				
				<option value="file8">storyblok-sync/internal/ui/browse_viewport.go (75.9%)</option>
				
				<option value="file9">storyblok-sync/internal/ui/filter.go (93.0%)</option>
				
				<option value="file10">storyblok-sync/internal/ui/handlers_browse_main.go (64.3%)</option>
				
				<option value="file11">storyblok-sync/internal/ui/handlers_preflight.go (55.8%)</option>
				
				<option value="file12">storyblok-sync/internal/ui/handlers_report.go (0.0%)</option>
				
				<option value="file13">storyblok-sync/internal/ui/handlers_setup.go (18.2%)</option>
				
				<option value="file14">storyblok-sync/internal/ui/handlers_sync.go (0.0%)</option>
				
				<option value="file15">storyblok-sync/internal/ui/init.go (94.7%)</option>
				
				<option value="file16">storyblok-sync/internal/ui/messages.go (3.7%)</option>
				
				<option value="file17">storyblok-sync/internal/ui/report.go (86.3%)</option>
				
				<option value="file18">storyblok-sync/internal/ui/sort.go (93.3%)</option>
				
				<option value="file19">storyblok-sync/internal/ui/styles.go (90.0%)</option>
				
				<option value="file20">storyblok-sync/internal/ui/sync.go (27.3%)</option>
				
				<option value="file21">storyblok-sync/internal/ui/sync/api_adapters.go (100.0%)</option>
				
				<option value="file22">storyblok-sync/internal/ui/sync/bulk_operations.go (0.0%)</option>
				
				<option value="file23">storyblok-sync/internal/ui/sync/content_manager.go (88.5%)</option>
				
				<option value="file24">storyblok-sync/internal/ui/sync/folder_builder.go (0.0%)</option>
				
				<option value="file25">storyblok-sync/internal/ui/sync/operations.go (0.0%)</option>
				
				<option value="file26">storyblok-sync/internal/ui/sync/orchestrator.go (46.9%)</option>
				
				<option value="file27">storyblok-sync/internal/ui/sync/preflight.go (10.3%)</option>
				
				<option value="file28">storyblok-sync/internal/ui/sync/story_sync.go (69.1%)</option>
				
				<option value="file29">storyblok-sync/internal/ui/sync/utils.go (22.3%)</option>
				
				<option value="file30">storyblok-sync/internal/ui/tree_lines.go (90.0%)</option>
				
				<option value="file31">storyblok-sync/internal/ui/types.go (100.0%)</option>
				
				<option value="file32">storyblok-sync/internal/ui/update_main.go (5.1%)</option>
				
				<option value="file33">storyblok-sync/internal/ui/utils.go (94.6%)</option>
				
				<option value="file34">storyblok-sync/internal/ui/view_browse.go (58.5%)</option>
				
				<option value="file35">storyblok-sync/internal/ui/view_main.go (9.3%)</option>
				
				<option value="file36">storyblok-sync/internal/ui/view_preflight.go (72.5%)</option>
				
				<option value="file37">storyblok-sync/internal/ui/view_report.go (0.0%)</option>
				
				<option value="file38">storyblok-sync/internal/ui/view_setup.go (0.0%)</option>
				
				<option value="file39">storyblok-sync/internal/ui/view_sync.go (0.0%)</option>
				
				<option value="file40">storyblok-sync/internal/ui/viewport_shared.go (87.0%)</option>
				
				<option value="file41">storyblok-sync/internal/ui/visible_helpers.go (91.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "sort"

        tea "github.com/charmbracelet/bubbletea"

        "storyblok-sync/internal/ui"
)

func main() <span class="cov0" title="0">{
        // Clean up old log files before starting
        cleanupOldLogFiles()

        // Configure logging based on DEBUG environment variable
        if len(os.Getenv("DEBUG")) &gt; 0 </span><span class="cov0" title="0">{
                // Enable Bubble Tea debug logging to file
                f, err := tea.LogToFile("debug.log", "debug")
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("fatal:", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">defer f.Close()

                // Redirect Go's standard logger to the same debug file
                debugFile, err := os.OpenFile("debug.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("fatal: could not open debug log file:", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">defer debugFile.Close()
                log.SetOutput(debugFile)

                fmt.Println("Debug logging enabled. Run 'tail -f debug.log' to view logs.")</span>
        } else<span class="cov0" title="0"> {
                // Disable all logging output to prevent TUI interference
                log.SetOutput(io.Discard)
        }</span>

        <span class="cov0" title="0">if _, err := tea.NewProgram(
                ui.InitialModel(),
                tea.WithAltScreen(),
        ).Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Println("error:", err)
                os.Exit(1)
        }</span>
}

// cleanupOldLogFiles removes old debug log files to prevent disk space accumulation
func cleanupOldLogFiles() <span class="cov0" title="0">{
        // Remove old debug.log files if they get too large (&gt;10MB)
        if stat, err := os.Stat("debug.log"); err == nil </span><span class="cov0" title="0">{
                if stat.Size() &gt; 10*1024*1024 </span><span class="cov0" title="0">{ // 10MB limit
                        // Rotate the log file by renaming it with timestamp
                        if err := os.Rename("debug.log", fmt.Sprintf("debug.log.%d", stat.ModTime().Unix())); err == nil </span><span class="cov0" title="0">{
                                // Clean up very old rotated log files (keep only last 3)
                                if files, err := filepath.Glob("debug.log.*"); err == nil &amp;&amp; len(files) &gt; 3 </span><span class="cov0" title="0">{
                                        // Sort files to get proper ordering
                                        sort.Strings(files)
                                        // Remove oldest files, keeping only the 3 most recent
                                        for i := 0; i &lt; len(files)-3; i++ </span><span class="cov0" title="0">{
                                                os.Remove(files[i])
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "bufio"
        "errors"
        "os"
        "path/filepath"
        "strings"
)

type Config struct {
        Token       string
        SourceSpace string
        TargetSpace string
        Path        string
}

func DefaultPath() string <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return ".sbrc" // fallback to current directory
        }</span>
        <span class="cov8" title="1">return filepath.Join(home, ".sbrc")</span>
}

func Load(path string) (Config, error) <span class="cov8" title="1">{
        cfg := Config{Path: path}
        if env := os.Getenv("SB_TOKEN"); env != "" </span><span class="cov8" title="1">{
                cfg.Token = strings.TrimSpace(env)
        }</span>
        <span class="cov8" title="1">f, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                if cfg.Token != "" </span><span class="cov8" title="1">{
                        return cfg, nil
                }</span>
                <span class="cov0" title="0">return cfg, err</span>
        }
        <span class="cov8" title="1">defer f.Close()

        s := bufio.NewScanner(f)
        for s.Scan() </span><span class="cov8" title="1">{
                line := strings.TrimSpace(s.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">k, v, ok := strings.Cut(line, "=")
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">k = strings.TrimSpace(k)
                v = strings.TrimSpace(v)
                switch k </span>{
                case "SB_TOKEN":<span class="cov8" title="1">
                        if cfg.Token == "" </span><span class="cov8" title="1">{
                                cfg.Token = v
                        }</span>
                case "SOURCE_SPACE_ID":<span class="cov8" title="1">
                        cfg.SourceSpace = v</span>
                case "TARGET_SPACE_ID":<span class="cov8" title="1">
                        cfg.TargetSpace = v</span>
                }
        }
        <span class="cov8" title="1">return cfg, nil</span>
}

func Save(path string, cfg Config) error <span class="cov8" title="1">{
        if strings.TrimSpace(cfg.Token) == "" </span><span class="cov8" title="1">{
                return errors.New("kein Token zum Speichern")
        }</span>
        <span class="cov8" title="1">_ = os.MkdirAll(filepath.Dir(path), 0o755)
        content := []string{
                "SB_TOKEN=" + cfg.Token,
        }
        if cfg.SourceSpace != "" </span><span class="cov8" title="1">{
                content = append(content, "SOURCE_SPACE_ID="+cfg.SourceSpace)
        }</span>
        <span class="cov8" title="1">if cfg.TargetSpace != "" </span><span class="cov8" title="1">{
                content = append(content, "TARGET_SPACE_ID="+cfg.TargetSpace)
        }</span>
        <span class="cov8" title="1">return os.WriteFile(path, []byte(strings.Join(content, "\n")+"\n"), 0o600)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package sb

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/url"
        "strings"
        "time"
)

const base = "https://mapi.storyblok.com/v1"

type Client struct {
        http  *http.Client
        token string
}

func New(token string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                http:  &amp;http.Client{Timeout: 10 * time.Second},
                token: token,
        }
}</span>

// ---------- Spaces ----------
type Space struct {
        ID        int    `json:"id"`
        Name      string `json:"name"`
        PlanLevel int    `json:"plan_level"`
}

type spacesResp struct {
        Spaces []Space `json:"spaces"`
}

func (c *Client) ListSpaces(ctx context.Context) ([]Space, error) <span class="cov8" title="1">{
        if c.token == "" </span><span class="cov8" title="1">{
                return nil, errors.New("token leer")
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "GET", base+"/spaces", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", c.token)
        req.Header.Add("Content-Type", "application/json")
        q := req.URL.Query()
        req.URL.RawQuery = q.Encode()

        res, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        if res.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, errors.New("spaces.list status " + res.Status)
        }</span>
        <span class="cov8" title="1">var payload spacesResp
        if err := json.NewDecoder(res.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return payload.Spaces, nil</span>
}

// ---------- Stories (flach) ----------

type TranslatedSlug struct {
        ID   *int   `json:"id,omitempty"`
        Lang string `json:"lang"`
        Name string `json:"name"`
        Path string `json:"path"`
}

type Story struct {
        ID                        int              `json:"id,omitempty"`
        UUID                      string           `json:"uuid,omitempty"`
        Name                      string           `json:"name"`
        Slug                      string           `json:"slug"`
        FullSlug                  string           `json:"full_slug"`
        Content                   json.RawMessage  `json:"content,omitempty"`
        ContentType               string           `json:"content_type,omitempty"`
        FolderID                  *int             `json:"parent_id,omitempty"`
        CreatedAt                 string           `json:"created_at,omitempty"`
        UpdatedAt                 string           `json:"updated_at,omitempty"`
        Published                 bool             `json:"published"`
        IsFolder                  bool             `json:"is_folder"`
        IsStartpage               bool             `json:"is_startpage"`
        Position                  int              `json:"position"`
        TagList                   []string         `json:"tag_list,omitempty"`
        TranslatedSlugs           []TranslatedSlug `json:"translated_slugs,omitempty"`
        TranslatedSlugsAttributes []TranslatedSlug `json:"translated_slugs_attributes,omitempty"`
}

type storiesResp struct {
        Stories []Story `json:"stories"`
        Total   int     `json:"total"`
        Page    int     `json:"page"`
        PerPage int     `json:"per_page"`
}

type ListStoriesOpts struct {
        SpaceID int
        Page    int
        PerPage int // 0 =&gt; Default 50
        // Optional später: by content type, folder, etc.
}

func (c *Client) ListStories(ctx context.Context, opt ListStoriesOpts) ([]Story, error) <span class="cov8" title="1">{
        if c.token == "" </span><span class="cov0" title="0">{
                return nil, errors.New("token leer")
        }</span>
        <span class="cov8" title="1">if opt.PerPage &lt;= 0 </span><span class="cov0" title="0">{
                opt.PerPage = 50
        }</span>
        <span class="cov8" title="1">page := opt.Page
        if page &lt;= 0 </span><span class="cov8" title="1">{
                page = 1
        }</span>

        <span class="cov8" title="1">var all []Story
        for </span><span class="cov8" title="1">{
                u, _ := url.Parse(base + "/spaces/" + fmt.Sprint(opt.SpaceID) + "/stories")
                q := u.Query()
                q.Set("page", fmt.Sprint(page))
                q.Set("per_page", fmt.Sprint(opt.PerPage))
                u.RawQuery = q.Encode()

                req, err := http.NewRequestWithContext(ctx, "GET", u.String(), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create request: %w", err)
                }</span>
                <span class="cov8" title="1">req.Header.Set("Authorization", c.token)
                req.Header.Add("Content-Type", "application/json")

                res, err := c.http.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer res.Body.Close()

                if res.StatusCode != 200 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("stories.list status %s", res.Status)
                }</span>

                <span class="cov8" title="1">var payload storiesResp
                if err := json.NewDecoder(res.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">all = append(all, payload.Stories...)

                // Einfacher Abbruch: wenn weniger als PerPage kam, sind wir durch
                if len(payload.Stories) &lt; opt.PerPage </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">page++</span>
        }
        <span class="cov8" title="1">return all, nil</span>
}

// storyResp is used for create/update/get responses.
type storyResp struct {
        Story Story `json:"story"`
}

// GetStory fetches a single story by ID.
func (c *Client) GetStory(ctx context.Context, spaceID, storyID int) (Story, error) <span class="cov8" title="1">{
        // Use the same fallback logic as GetStoryWithContent
        return c.GetStoryWithContent(ctx, spaceID, storyID)
}</span>

// CreateStory creates a new story (or folder) in the target space.
func (c *Client) CreateStory(ctx context.Context, spaceID int, st Story) (Story, error) <span class="cov8" title="1">{
        if c.token == "" </span><span class="cov8" title="1">{
                return Story{}, errors.New("token leer")
        }</span>
        <span class="cov8" title="1">u := fmt.Sprintf(base+"/spaces/%d/stories", spaceID)
        payload := storyResp{Story: st}
        body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "POST", u, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", c.token)
        req.Header.Add("Content-Type", "application/json")
        res, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        if res.StatusCode != 200 &amp;&amp; res.StatusCode != 201 </span><span class="cov0" title="0">{
                return Story{}, fmt.Errorf("story.create status %s", res.Status)
        }</span>
        <span class="cov8" title="1">var resp storyResp
        if err := json.NewDecoder(res.Body).Decode(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">return resp.Story, nil</span>
}

// UpdateStory updates an existing story in the target space.
func (c *Client) UpdateStory(ctx context.Context, spaceID int, st Story, publish bool) (Story, error) <span class="cov8" title="1">{
        if c.token == "" </span><span class="cov0" title="0">{
                return Story{}, errors.New("token leer")
        }</span>
        <span class="cov8" title="1">if st.ID == 0 </span><span class="cov0" title="0">{
                return Story{}, errors.New("story ID fehlt")
        }</span>
        <span class="cov8" title="1">u := fmt.Sprintf(base+"/spaces/%d/stories/%d", spaceID, st.ID)
        payload := map[string]interface{}{
                "story":        st,
                "force_update": "1",
        }
        if !st.IsFolder &amp;&amp; publish </span><span class="cov8" title="1">{
                payload["publish"] = 1
        }</span>
        <span class="cov8" title="1">body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "PUT", u, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", c.token)
        req.Header.Add("Content-Type", "application/json")
        res, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        if res.StatusCode != 200 &amp;&amp; res.StatusCode != 201 </span><span class="cov0" title="0">{
                bodyBytes, err := io.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return Story{}, fmt.Errorf("failed to read response body: %w", err)
                }</span>
                <span class="cov0" title="0">var apiErr struct {
                        Error string `json:"error"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;apiErr); err == nil &amp;&amp; apiErr.Error != "" </span><span class="cov0" title="0">{
                        return Story{}, errors.New(apiErr.Error)
                }</span>
                <span class="cov0" title="0">return Story{}, fmt.Errorf("story.update status %s: %s", res.Status, strings.TrimSpace(string(bodyBytes)))</span>
        }
        <span class="cov8" title="1">var resp storyResp
        if err := json.NewDecoder(res.Body).Decode(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">return resp.Story, nil</span>
}

// CreateStoryWithPublish creates a new story with proper payload structure
func (c *Client) CreateStoryWithPublish(ctx context.Context, spaceID int, st Story, publish bool) (Story, error) <span class="cov8" title="1">{
        if c.token == "" </span><span class="cov0" title="0">{
                return Story{}, errors.New("token leer")
        }</span>
        <span class="cov8" title="1">u := fmt.Sprintf(base+"/spaces/%d/stories", spaceID)
        payload := map[string]interface{}{
                "story":        st,
                "force_update": "1",
        }
        if !st.IsFolder &amp;&amp; publish </span><span class="cov8" title="1">{
                payload["publish"] = 1
        }</span>

        // DEBUG: Log the payload before marshalling
        <span class="cov8" title="1">log.Printf("DEBUG: Creating story - Before marshal:")
        log.Printf("DEBUG: Story has content: %t", len(st.Content) &gt; 0)
        if len(st.Content) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("DEBUG: Content keys: %v", contentKeysFromRaw(st.Content))
        }</span>
        <span class="cov8" title="1">log.Printf("DEBUG: Story is folder: %t", st.IsFolder)
        log.Printf("DEBUG: Story published: %t", st.Published)

        body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>

        // DEBUG: Log the actual JSON being sent
        <span class="cov8" title="1">log.Printf("DEBUG: JSON payload being sent (%d bytes):", len(body))
        if len(body) &lt; 2000 </span><span class="cov8" title="1">{
                log.Printf("DEBUG: Full JSON: %s", string(body))
        }</span> else<span class="cov0" title="0"> {
                log.Printf("DEBUG: JSON too large, truncated: %s...", string(body[:2000]))
        }</span>

        // DEBUG: Try minimal payload approach for debugging
        <span class="cov8" title="1">log.Printf("DEBUG: Story UUID: %s", st.UUID)
        log.Printf("DEBUG: Story Name: %s", st.Name)
        log.Printf("DEBUG: Story Slug: %s", st.Slug)
        log.Printf("DEBUG: Story FullSlug: %s", st.FullSlug)
        log.Printf("DEBUG: Story FolderID: %v", st.FolderID)
        log.Printf("DEBUG: Story Published: %t", st.Published)
        log.Printf("DEBUG: Story IsFolder: %t", st.IsFolder)
        req, err := http.NewRequestWithContext(ctx, "POST", u, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", c.token)
        req.Header.Add("Content-Type", "application/json")
        res, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        if res.StatusCode != 200 &amp;&amp; res.StatusCode != 201 </span><span class="cov0" title="0">{
                bodyBytes, err := io.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return Story{}, fmt.Errorf("failed to read response body: %w", err)
                }</span>
                // DEBUG: log body for troubleshooting
                <span class="cov0" title="0">if res.StatusCode == 422 </span><span class="cov0" title="0">{
                        log.Printf("DEBUG: 422 Error response body: %s", string(bodyBytes))
                }</span>
                <span class="cov0" title="0">var apiErr struct {
                        Error string `json:"error"`
                }
                if err := json.Unmarshal(bodyBytes, &amp;apiErr); err == nil &amp;&amp; apiErr.Error != "" </span><span class="cov0" title="0">{
                        return Story{}, errors.New(apiErr.Error)
                }</span>
                <span class="cov0" title="0">return Story{}, fmt.Errorf("story.create status %s: %s", res.Status, strings.TrimSpace(string(bodyBytes)))</span>
        }
        <span class="cov8" title="1">var resp storyResp
        if err := json.NewDecoder(res.Body).Decode(&amp;resp); err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">return resp.Story, nil</span>
}

// GetStoriesBySlug finds stories by slug using with_slug parameter
func (c *Client) GetStoriesBySlug(ctx context.Context, spaceID int, slug string) ([]Story, error) <span class="cov8" title="1">{
        if c.token == "" </span><span class="cov8" title="1">{
                return nil, errors.New("token leer")
        }</span>
        <span class="cov8" title="1">u, _ := url.Parse(base + "/spaces/" + fmt.Sprint(spaceID) + "/stories")
        q := u.Query()
        q.Set("with_slug", slug)
        u.RawQuery = q.Encode()

        req, err := http.NewRequestWithContext(ctx, "GET", u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", c.token)
        req.Header.Add("Content-Type", "application/json")

        res, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()

        if res.StatusCode != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("stories.get_by_slug status %s", res.Status)
        }</span>

        <span class="cov8" title="1">var payload storiesResp
        if err := json.NewDecoder(res.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return payload.Stories, nil</span>
}

// UpdateStoryUUID updates the UUID of a story to maintain identity
func (c *Client) UpdateStoryUUID(ctx context.Context, spaceID, storyID int, uuid string) error <span class="cov8" title="1">{
        if c.token == "" </span><span class="cov8" title="1">{
                return errors.New("token leer")
        }</span>
        <span class="cov8" title="1">u := fmt.Sprintf(base+"/spaces/%d/stories/%d/update_uuid", spaceID, storyID)
        payload := map[string]string{"uuid": uuid}
        body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "PUT", u, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", c.token)
        req.Header.Add("Content-Type", "application/json")
        res, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        if res.StatusCode != 200 &amp;&amp; res.StatusCode != 201 </span><span class="cov0" title="0">{
                return fmt.Errorf("story.update_uuid status %s", res.Status)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetStoryWithContent fetches a story with complete content data
func (c *Client) GetStoryWithContent(ctx context.Context, spaceID, storyID int) (Story, error) <span class="cov8" title="1">{
        if c.token == "" </span><span class="cov8" title="1">{
                return Story{}, errors.New("token leer")
        }</span>

        // Based on Storyblok CLI: just fetch by ID without version parameter
        // The CLI does: client.get(`spaces/${spaceId}/stories/${storyId}`)
        <span class="cov8" title="1">u := fmt.Sprintf(base+"/spaces/%d/stories/%d", spaceID, storyID)

        req, err := http.NewRequestWithContext(ctx, "GET", u, nil)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", c.token)
        req.Header.Add("Content-Type", "application/json")
        res, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        if res.StatusCode != 200 </span><span class="cov0" title="0">{
                return Story{}, fmt.Errorf("story.get status %s", res.Status)
        }</span>
        <span class="cov8" title="1">var payload storyResp
        if err := json.NewDecoder(res.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>

        // DEBUG: Log what we received from the API
        <span class="cov8" title="1">story := payload.Story
        log.Printf("DEBUG: Fetched story %d (%s) - Content present: %t", story.ID, story.FullSlug, len(story.Content) &gt; 0)
        if len(story.Content) &gt; 0 </span><span class="cov8" title="1">{
                log.Printf("DEBUG: Fetched content keys: %v", contentKeysFromRaw(story.Content))
        }</span> else<span class="cov0" title="0"> {
                log.Printf("DEBUG: Story content is empty - this is likely the issue!")
        }</span>

        <span class="cov8" title="1">return story, nil</span>
}

// getStoryWithVersion fetches story with specific version parameter
func (c *Client) getStoryWithVersion(ctx context.Context, spaceID, storyID int, version string) (Story, error) <span class="cov8" title="1">{
        var u string
        if version == "" </span><span class="cov8" title="1">{
                // Include resolve_relations to get full content
                u = fmt.Sprintf(base+"/spaces/%d/stories/%d?resolve_relations=1", spaceID, storyID)
        }</span> else<span class="cov8" title="1"> {
                // Include both version and resolve_relations for full content
                u = fmt.Sprintf(base+"/spaces/%d/stories/%d?version=%s&amp;resolve_relations=1", spaceID, storyID, version)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "GET", u, nil)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", c.token)
        req.Header.Add("Content-Type", "application/json")
        res, err := c.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        if res.StatusCode != 200 </span><span class="cov0" title="0">{
                return Story{}, fmt.Errorf("story.get status %s", res.Status)
        }</span>
        <span class="cov8" title="1">var payload storyResp
        if err := json.NewDecoder(res.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return Story{}, err
        }</span>
        <span class="cov8" title="1">return payload.Story, nil</span>
}

// contentKeysFromRaw extracts top-level keys from a JSON raw message.
func contentKeysFromRaw(raw json.RawMessage) []string <span class="cov8" title="1">{
        if len(raw) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var tmp map[string]interface{}
        if err := json.Unmarshal(raw, &amp;tmp); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">keys := make([]string, 0, len(tmp))
        for k := range tmp </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package ui

import (
        "strings"
)

// applyFilter applies search and prefix filters to the story list
func (m *Model) applyFilter() <span class="cov8" title="1">{
        q := strings.TrimSpace(strings.ToLower(m.search.query))
        pref := strings.TrimSpace(strings.ToLower(m.filter.prefix))

        // Build searchable text for each story
        base := make([]string, len(m.storiesSource))
        for i, st := range m.storiesSource </span><span class="cov8" title="1">{
                name := st.Name
                if name == "" </span><span class="cov0" title="0">{
                        name = st.Slug
                }</span>
                <span class="cov8" title="1">base[i] = strings.ToLower(name + "  " + st.Slug + "  " + st.FullSlug)</span>
        }

        // Apply prefix filter first
        <span class="cov8" title="1">idx := filterByPrefix(m.storiesSource, pref)

        // If no search query, use prefix-filtered results
        if q == "" </span><span class="cov8" title="1">{
                m.search.filteredIdx = append(m.search.filteredIdx[:0], idx...)
                m.selection.listIndex = 0
                m.refreshVisible()
                return
        }</span>

        // Try substring search first (faster and more predictable)
        <span class="cov8" title="1">sub := filterBySubstring(q, base, idx, m.filterCfg)
        if len(sub) &gt; 0 </span><span class="cov0" title="0">{
                m.search.filteredIdx = sub
                m.selection.listIndex = 0
                m.refreshVisible()
                return
        }</span>

        // Fall back to fuzzy search
        <span class="cov8" title="1">m.search.filteredIdx = filterByFuzzy(q, base, idx, m.filterCfg)
        m.selection.listIndex = 0
        m.refreshVisible()</span>
}

// refreshVisible updates the visible item indices based on current filters and hierarchy
func (m *Model) refreshVisible() <span class="cov8" title="1">{
        base := m.search.filteredIdx
        if base == nil </span><span class="cov0" title="0">{
                base = make([]int, len(m.storiesSource))
                for i := range m.storiesSource </span><span class="cov0" title="0">{
                        base[i] = i
                }</span>
        }

        <span class="cov8" title="1">included := make(map[int]bool, len(base))
        for _, idx := range base </span><span class="cov8" title="1">{
                included[idx] = true
        }</span>

        // Build parent-child mapping for hierarchy handling
        <span class="cov8" title="1">children := make(map[int][]int)
        for i, story := range m.storiesSource </span><span class="cov8" title="1">{
                if story.FolderID != nil </span><span class="cov8" title="1">{
                        pid := *story.FolderID
                        children[pid] = append(children[pid], i)
                }</span>
        }

        // Recursive function to include visible items respecting folder collapse state
        <span class="cov8" title="1">var addVisible func(int) bool
        addVisible = func(idx int) bool </span><span class="cov8" title="1">{
                if idx &gt;= len(m.storiesSource) </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">story := m.storiesSource[idx]

                // If this item matches the filter, include it
                shouldInclude := included[idx]

                if shouldInclude </span><span class="cov8" title="1">{
                        m.visibleIdx = append(m.visibleIdx, idx)
                }</span>

                // If it's a folder and not collapsed, process children
                <span class="cov8" title="1">if story.IsFolder &amp;&amp; !m.folderCollapsed[story.ID] </span><span class="cov8" title="1">{
                        for _, childIdx := range children[story.ID] </span><span class="cov8" title="1">{
                                addVisible(childIdx)
                        }</span>
                }

                <span class="cov8" title="1">return shouldInclude</span>
        }

        // Reset visible indices
        <span class="cov8" title="1">m.visibleIdx = m.visibleIdx[:0]

        // Add root level items and their visible children
        for i, story := range m.storiesSource </span><span class="cov8" title="1">{
                if story.FolderID == nil </span><span class="cov8" title="1">{
                        addVisible(i)
                }</span>
        }
}

// These filtering functions are already defined in filter.go
// We'll use the existing implementations
</pre>
		
		<pre class="file" id="file4" style="display: none">package ui

import (
        "strings"

        tea "github.com/charmbracelet/bubbletea"
)

// handlePrefixFilterInput handles prefix filter input mode
func (m Model) handlePrefixFilterInput(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov0" title="0">{
        key := msg.String()

        switch key </span>{
        case "esc":<span class="cov0" title="0">
                m.filter.prefixInput.Blur()
                if strings.TrimSpace(m.filter.prefixInput.Value()) == "" </span><span class="cov0" title="0">{
                        m.filter.prefix = ""
                }</span>
                <span class="cov0" title="0">m.filter.prefixing = false
                m.applyFilter()
                m.updateBrowseViewport()
                return m, nil</span>
        case "enter":<span class="cov0" title="0">
                m.filter.prefix = strings.TrimSpace(m.filter.prefixInput.Value())
                m.filter.prefixing = false
                m.filter.prefixInput.Blur()
                m.applyFilter()
                m.updateBrowseViewport()
                return m, nil</span>
        case "ctrl+c", "q":<span class="cov0" title="0">
                return m, tea.Quit</span>
        default:<span class="cov0" title="0">
                var cmd tea.Cmd
                m.filter.prefixInput, cmd = m.filter.prefixInput.Update(msg)
                return m, cmd</span>
        }
}

// handleSearchInput handles search input mode
func (m Model) handleSearchInput(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov8" title="1">{
        key := msg.String()

        switch key </span>{
        case "esc":<span class="cov0" title="0">
                // ESC: wenn Query leer -&gt; Suche schließen, sonst nur löschen
                current := strings.TrimSpace(m.search.searchInput.Value())
                if current == "" </span><span class="cov0" title="0">{
                        m.search.searching = false
                        m.search.query = ""
                        m.search.searchInput.Blur()
                        m.collapseAllFolders()
                }</span> else<span class="cov0" title="0"> {
                        m.search.query = ""
                        m.search.searchInput.SetValue("")
                        m.collapseAllFolders()
                        m.applyFilter()
                }</span>
                <span class="cov0" title="0">m.updateBrowseViewport()
                return m, nil</span>
        case "enter":<span class="cov0" title="0">
                m.search.query = strings.TrimSpace(m.search.searchInput.Value())
                m.search.searching = false
                m.search.searchInput.Blur()
                m.applyFilter()
                m.updateBrowseViewport()
                return m, nil</span>
        case "ctrl+c", "q":<span class="cov0" title="0">
                return m, tea.Quit</span>
        default:<span class="cov8" title="1">
                // Live search: update query as user types
                var cmd tea.Cmd
                m.search.searchInput, cmd = m.search.searchInput.Update(msg)
                // Update the query immediately for live filtering
                newQuery := strings.TrimSpace(m.search.searchInput.Value())
                if newQuery != m.search.query </span><span class="cov8" title="1">{
                        // Expand folders when starting search, collapse when clearing
                        if m.search.query == "" &amp;&amp; newQuery != "" </span><span class="cov8" title="1">{
                                m.expandAllFolders()
                        }</span>
                        <span class="cov8" title="1">if m.search.query != "" &amp;&amp; newQuery == "" </span><span class="cov0" title="0">{
                                m.collapseAllFolders()
                        }</span>
                        <span class="cov8" title="1">m.search.query = newQuery
                        m.applyFilter()
                        m.updateBrowseViewport()</span>
                }
                <span class="cov8" title="1">return m, cmd</span>
        }
}

// handleBrowseSearchAndFilterControls handles search and filter toggle keys
func (m Model) handleBrowseSearchAndFilterControls(key string) (Model, tea.Cmd) <span class="cov8" title="1">{
        switch key </span>{
        case "f":<span class="cov0" title="0">
                // Toggle search
                if !m.search.searching </span><span class="cov0" title="0">{
                        m.search.searching = true
                        m.search.searchInput.Focus()
                        return m, m.search.searchInput.Focus()
                }</span> else<span class="cov0" title="0"> {
                        m.search.searching = false
                        m.search.searchInput.Blur()
                        return m, nil
                }</span>
        case "F":<span class="cov8" title="1">
                // Clear search
                m.search.query = ""
                m.search.searchInput.SetValue("")
                m.collapseAllFolders()
                m.applyFilter()
                m.updateBrowseViewport()
                return m, nil</span>

        case "p", "P":<span class="cov0" title="0">
                // Toggle prefix filter
                if !m.filter.prefixing </span><span class="cov0" title="0">{
                        m.filter.prefixing = true
                        m.filter.prefixInput.Focus()
                        return m, m.filter.prefixInput.Focus()
                }</span> else<span class="cov0" title="0"> {
                        m.filter.prefixing = false
                        m.filter.prefixInput.Blur()
                        return m, nil
                }</span>

        case "c":<span class="cov0" title="0">
                // Clear all filters and selections
                m.search.query = ""
                m.filter.prefix = ""
                m.search.searchInput.SetValue("")
                m.filter.prefixInput.SetValue("")
                m.selection.selected = make(map[string]bool)
                m.collapseAllFolders()
                m.applyFilter()
                m.updateBrowseViewport()
                return m, nil</span>
        }

        <span class="cov8" title="1">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package ui

import tea "github.com/charmbracelet/bubbletea"

// handleBrowseTreeNavigation handles tree expand/collapse navigation
func (m Model) handleBrowseTreeNavigation(key string) (Model, tea.Cmd) <span class="cov8" title="1">{
        switch key </span>{
        case "l":<span class="cov8" title="1">
                // Expand folder
                if m.itemsLen() == 0 </span><span class="cov0" title="0">{
                        return m, nil
                }</span>
                <span class="cov8" title="1">st := m.itemAt(m.selection.listIndex)
                if st.IsFolder </span><span class="cov8" title="1">{
                        m.folderCollapsed[st.ID] = false
                        m.refreshVisible()
                        m.updateBrowseViewport()
                }</span>
        case "h":<span class="cov8" title="1">
                // Collapse folder or navigate to parent
                if m.itemsLen() == 0 </span><span class="cov0" title="0">{
                        return m, nil
                }</span>
                <span class="cov8" title="1">st := m.itemAt(m.selection.listIndex)
                if st.IsFolder </span><span class="cov0" title="0">{
                        m.folderCollapsed[st.ID] = true
                        m.refreshVisible()
                        m.updateBrowseViewport()
                }</span> else<span class="cov8" title="1"> if st.FolderID != nil </span><span class="cov8" title="1">{
                        pid := *st.FolderID
                        m.folderCollapsed[pid] = true
                        m.refreshVisible()
                        if vis := m.visibleIndexByID(pid); vis &gt;= 0 </span><span class="cov8" title="1">{
                                m.selection.listIndex = vis
                                m.ensureCursorVisible()
                        }</span>
                        <span class="cov8" title="1">m.updateBrowseViewport()</span>
                }
        case "H":<span class="cov0" title="0">
                // Collapse all folders
                m.collapseAllFolders()
                m.updateBrowseViewport()</span>
        case "L":<span class="cov0" title="0">
                // Expand all folders
                m.expandAllFolders()
                m.updateBrowseViewport()</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

// handleBrowseCursorMovement handles cursor movement navigation
func (m Model) handleBrowseCursorMovement(key string) (Model, tea.Cmd) <span class="cov0" title="0">{
        switch key </span>{
        case "j", "down":<span class="cov0" title="0">
                // Move cursor down
                if m.selection.listIndex &lt; m.itemsLen()-1 </span><span class="cov0" title="0">{
                        m.selection.listIndex++
                        m.ensureCursorVisible()
                        m.updateBrowseViewport()
                }</span>
        case "k", "up":<span class="cov0" title="0">
                // Move cursor up
                if m.selection.listIndex &gt; 0 </span><span class="cov0" title="0">{
                        m.selection.listIndex--
                        m.ensureCursorVisible()
                        m.updateBrowseViewport()
                }</span>
        case "ctrl+d", "pgdown":<span class="cov0" title="0">
                // Page down
                if m.itemsLen() &gt; 0 </span><span class="cov0" title="0">{
                        jump := m.viewport.Height
                        if jump &lt;= 0 </span><span class="cov0" title="0">{
                                jump = 10
                        }</span>
                        <span class="cov0" title="0">m.selection.listIndex += jump
                        if m.selection.listIndex &gt; m.itemsLen()-1 </span><span class="cov0" title="0">{
                                m.selection.listIndex = m.itemsLen() - 1
                        }</span>
                        <span class="cov0" title="0">m.ensureCursorVisible()
                        m.updateBrowseViewport()</span>
                }
        case "ctrl+u", "pgup":<span class="cov0" title="0">
                // Page up
                jump := m.viewport.Height
                if jump &lt;= 0 </span><span class="cov0" title="0">{
                        jump = 10
                }</span>
                <span class="cov0" title="0">m.selection.listIndex -= jump
                if m.selection.listIndex &lt; 0 </span><span class="cov0" title="0">{
                        m.selection.listIndex = 0
                }</span>
                <span class="cov0" title="0">m.ensureCursorVisible()
                m.updateBrowseViewport()</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

// handleBrowseActions handles action keys (rescan, start sync)
func (m Model) handleBrowseActions(key string) (Model, tea.Cmd) <span class="cov0" title="0">{
        switch key </span>{
        case "r":<span class="cov0" title="0">
                // Rescan stories
                m.state = stateScanning
                return m, m.scanStoriesCmd()</span>
        case "s":<span class="cov0" title="0">
                // Start sync
                if len(m.selection.selected) == 0 </span><span class="cov0" title="0">{
                        m.statusMsg = "Keine Elemente ausgewählt!"
                        return m, nil
                }</span>
                <span class="cov0" title="0">m.startPreflight()
                return m, nil</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package ui

import (
        tea "github.com/charmbracelet/bubbletea"
        "storyblok-sync/internal/sb"
)

// handleBrowseSelection handles item selection with space key
func (m Model) handleBrowseSelection() (Model, tea.Cmd) <span class="cov8" title="1">{
        if m.itemsLen() == 0 </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        <span class="cov8" title="1">st := m.itemAt(m.selection.listIndex)
        if m.selection.selected == nil </span><span class="cov0" title="0">{
                m.selection.selected = make(map[string]bool)
        }</span>

        <span class="cov8" title="1">if st.IsFolder </span><span class="cov8" title="1">{
                m.toggleFolderSelection(st)
        }</span> else<span class="cov8" title="1"> {
                m.selection.selected[st.FullSlug] = !m.selection.selected[st.FullSlug]
        }</span>

        // Move cursor down after selection
        <span class="cov8" title="1">if m.selection.listIndex &lt; m.itemsLen()-1 </span><span class="cov8" title="1">{
                m.selection.listIndex++
                m.ensureCursorVisible()
        }</span>
        <span class="cov8" title="1">m.updateBrowseViewport()

        return m, nil</span>
}

// toggleFolderSelection toggles selection for a folder and all its children
func (m Model) toggleFolderSelection(st sb.Story) <span class="cov8" title="1">{
        // Determine new selection state based on current folder state
        mark := !m.selection.selected[st.FullSlug]
        prefix := st.FullSlug

        // Apply to folder and all children
        for _, story := range m.storiesSource </span><span class="cov8" title="1">{
                if story.FullSlug == prefix || (len(story.FullSlug) &gt; len(prefix) &amp;&amp;
                        story.FullSlug[:len(prefix)] == prefix &amp;&amp;
                        len(story.FullSlug) &gt; len(prefix) &amp;&amp;
                        story.FullSlug[len(prefix)] == '/') </span><span class="cov8" title="1">{
                        m.selection.selected[story.FullSlug] = mark
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package ui

import "storyblok-sync/internal/sb"

// collapseAllFolders collapses all folders in the tree
func (m *Model) collapseAllFolders() <span class="cov8" title="1">{
        for id := range m.folderCollapsed </span><span class="cov8" title="1">{
                m.folderCollapsed[id] = true
        }</span>
        <span class="cov8" title="1">m.refreshVisible()</span>
}

// expandAllFolders expands all folders in the tree
func (m *Model) expandAllFolders() <span class="cov8" title="1">{
        for id := range m.folderCollapsed </span><span class="cov8" title="1">{
                m.folderCollapsed[id] = false
        }</span>
        <span class="cov8" title="1">m.refreshVisible()</span>
}

// visibleIndexByID finds the visible index for a story by its ID
func (m *Model) visibleIndexByID(id int) int <span class="cov8" title="1">{
        if idx, ok := m.storyIdx[id]; ok </span><span class="cov8" title="1">{
                for i, v := range m.visibleIdx </span><span class="cov8" title="1">{
                        if v == idx </span><span class="cov8" title="1">{
                                return i
                        }</span>
                }
        }
        <span class="cov0" title="0">return -1</span>
}

// itemsLen returns the count of visible items
func (m *Model) itemsLen() int <span class="cov8" title="1">{
        return len(m.visibleIdx)
}</span>

// itemAt returns the story at the given visible index
func (m *Model) itemAt(visIdx int) sb.Story <span class="cov8" title="1">{
        if visIdx &lt; 0 || visIdx &gt;= len(m.visibleIdx) </span><span class="cov0" title="0">{
                return sb.Story{} // Return empty story as fallback
        }</span>
        <span class="cov8" title="1">sourceIdx := m.visibleIdx[visIdx]
        if sourceIdx &lt; 0 || sourceIdx &gt;= len(m.storiesSource) </span><span class="cov0" title="0">{
                return sb.Story{} // Return empty story as fallback
        }</span>
        <span class="cov8" title="1">return m.storiesSource[sourceIdx]</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package ui

import (
        "github.com/charmbracelet/lipgloss"
)

// ensureCursorVisible ensures the cursor stays within the viewport bounds
func (m *Model) ensureCursorVisible() <span class="cov8" title="1">{
        n := m.itemsLen()
        if n == 0 </span><span class="cov0" title="0">{
                m.selection.listIndex = 0
                return
        }</span>
        <span class="cov8" title="1">if m.selection.listIndex &lt; 0 </span><span class="cov0" title="0">{
                m.selection.listIndex = 0
        }</span>
        <span class="cov8" title="1">if m.selection.listIndex &gt; n-1 </span><span class="cov0" title="0">{
                m.selection.listIndex = n - 1
        }</span>

        // Calculate which line in the viewport content the cursor is on
        <span class="cov8" title="1">cursorLine := m.calculateCursorLine()

        // Adjust viewport using shared helper
        m.ensureCursorInViewport(cursorLine)</span>
}

// calculateCursorLine calculates the actual visual line number where the cursor appears
func (m *Model) calculateCursorLine() int <span class="cov8" title="1">{
        total := m.itemsLen()
        if total == 0 || m.selection.listIndex &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Get ALL visible stories (not just up to cursor) via shared helper
        <span class="cov8" title="1">stories, _ := m.visibleOrderBrowse()

        // Generate the complete tree structure exactly as in view_browse.go
        treeLines := generateTreeLinesFromStories(stories)

        // Calculate visual lines up to the cursor position
        totalLines := 0
        contentWidth := m.width - 4 // Same as view: cursorCell + markCell + content styled width
        if contentWidth &lt;= 0 </span><span class="cov8" title="1">{
                contentWidth = 80
        }</span>

        // Count lines up to (but not including) the cursor position
        <span class="cov8" title="1">cursorPos := m.selection.listIndex
        if cursorPos &gt; len(treeLines) </span><span class="cov0" title="0">{
                cursorPos = len(treeLines)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; cursorPos; i++ </span><span class="cov8" title="1">{
                if i &gt;= len(treeLines) </span><span class="cov0" title="0">{
                        break</span>
                }

                // Apply the same styling as in view_browse.go
                <span class="cov8" title="1">styledContent := lipgloss.NewStyle().Width(contentWidth).Render(treeLines[i])

                // Count wrapped lines for this styled content
                wrappedLines := m.countWrappedLines(styledContent)
                totalLines += wrappedLines</span>
        }

        <span class="cov8" title="1">return totalLines</span>
}

// generateTreeLines generates tree structure exactly as in view_browse.go
// generateTreeLines is now shared in tree_lines.go

// countWrappedLines counts how many display lines a piece of styled content takes
// countWrappedLines moved to viewport_shared.go for reuse
</pre>
		
		<pre class="file" id="file9" style="display: none">package ui

import (
        "strings"

        "github.com/sahilm/fuzzy"
        "storyblok-sync/internal/sb"
)

// FilterConfig bundles tuning parameters for filtering and search operations.
type FilterConfig struct {
        MinCoverage float64 // minimal share of the query that must match
        MaxSpread   int     // maximal distance between first and last match index
        MaxResults  int     // upper limit of returned results
}

// filterByPrefix returns indices of stories whose full slug begins with the
// provided prefix. If the prefix is empty, indices of all stories are returned.
func filterByPrefix(stories []sb.Story, prefix string) []int <span class="cov8" title="1">{
        idx := make([]int, 0, len(stories))
        if prefix != "" </span><span class="cov8" title="1">{
                for i, st := range stories </span><span class="cov8" title="1">{
                        if strings.HasPrefix(strings.ToLower(st.FullSlug), prefix) </span><span class="cov8" title="1">{
                                idx = append(idx, i)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for i := range stories </span><span class="cov8" title="1">{
                        idx = append(idx, i)
                }</span>
        }
        <span class="cov8" title="1">return idx</span>
}

// filterBySubstring performs a simple substring check against the prepared base
// list and returns matching indices limited by cfg.MaxResults.
func filterBySubstring(q string, base []string, idx []int, cfg FilterConfig) []int <span class="cov8" title="1">{
        sub := make([]int, 0, min(cfg.MaxResults, len(idx)))
        for _, i := range idx </span><span class="cov8" title="1">{
                if strings.Contains(base[i], q) </span><span class="cov8" title="1">{
                        sub = append(sub, i)
                        if len(sub) &gt;= cfg.MaxResults </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return sub</span>
}

// filterByFuzzy applies fuzzy matching on the subset defined by idx and
// filters results based on coverage and spread thresholds from cfg.
func filterByFuzzy(q string, base []string, idx []int, cfg FilterConfig) []int <span class="cov8" title="1">{
        subset := make([]string, len(idx))
        mapBack := make([]int, len(idx))
        for j, i := range idx </span><span class="cov8" title="1">{
                subset[j] = base[i]
                mapBack[j] = i
        }</span>
        <span class="cov8" title="1">matches := fuzzy.Find(q, subset)

        pruned := make([]int, 0, len(matches))
        for _, mt := range matches </span><span class="cov8" title="1">{
                if matchCoverage(q, mt) &lt; cfg.MinCoverage </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if matchSpread(mt) &gt; cfg.MaxSpread </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">pruned = append(pruned, mapBack[mt.Index])
                if len(pruned) &gt;= cfg.MaxResults </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(pruned) == 0 </span><span class="cov8" title="1">{
                for i := 0; i &lt; len(matches) &amp;&amp; i &lt; cfg.MaxResults; i++ </span><span class="cov8" title="1">{
                        pruned = append(pruned, mapBack[matches[i].Index])
                }</span>
        }
        <span class="cov8" title="1">return pruned</span>
}

// matchCoverage returns the ratio of matched characters to the query length.
func matchCoverage(q string, m fuzzy.Match) float64 <span class="cov8" title="1">{
        if len(q) == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov8" title="1">return float64(len(m.MatchedIndexes)) / float64(len(q))</span>
}

// matchSpread returns the distance between the first and last matched index.
func matchSpread(m fuzzy.Match) int <span class="cov8" title="1">{
        if len(m.MatchedIndexes) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return m.MatchedIndexes[len(m.MatchedIndexes)-1] - m.MatchedIndexes[0]</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package ui

import (
        tea "github.com/charmbracelet/bubbletea"
)

// handleBrowseListKey handles all key events in the browse list state.
// This function now delegates to specialized handlers in other files.
func (m Model) handleBrowseListKey(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov8" title="1">{
        key := msg.String()

        // Handle input modes first
        if m.filter.prefixing </span><span class="cov0" title="0">{
                return m.handlePrefixFilterInput(msg)
        }</span>

        <span class="cov8" title="1">if m.search.searching </span><span class="cov8" title="1">{
                return m.handleSearchInput(msg)
        }</span>

        // Handle search and filter controls
        <span class="cov8" title="1">if newM, cmd := m.handleBrowseSearchAndFilterControls(key); cmd != nil || key == "f" || key == "F" || key == "p" || key == "P" || key == "c" </span><span class="cov8" title="1">{
                return newM, cmd
        }</span>

        // Handle other key bindings
        <span class="cov8" title="1">switch key </span>{
        case "ctrl+c", "q":<span class="cov0" title="0">
                return m, tea.Quit</span>

        // Tree navigation
        case "l", "h", "H", "L":<span class="cov8" title="1">
                return m.handleBrowseTreeNavigation(key)</span>

        // Cursor movement
        case "j", "down", "k", "up", "ctrl+d", "pgdown", "ctrl+u", "pgup":<span class="cov0" title="0">
                return m.handleBrowseCursorMovement(key)</span>

        // Selection
        case " ":<span class="cov8" title="1">
                return m.handleBrowseSelection()</span>

        // Actions
        case "r", "s":<span class="cov0" title="0">
                return m.handleBrowseActions(key)</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package ui

import (
        "context"
        "fmt"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"

        "storyblok-sync/internal/sb"
)

func (m Model) handlePreflightKey(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov8" title="1">{
        if m.syncing </span><span class="cov0" title="0">{
                return m, nil
        }</span>
        <span class="cov8" title="1">key := msg.String()
        switch key </span>{
        case "l":<span class="cov0" title="0">
                // Expand folder under cursor
                if len(m.preflight.items) &gt; 0 &amp;&amp; m.preflight.listIndex &lt; len(m.preflight.items) </span><span class="cov0" title="0">{
                        // Find actual item index from visible order
                        if m.preflight.listIndex &gt;= 0 &amp;&amp; m.preflight.listIndex &lt; len(m.preflight.visibleIdx) </span><span class="cov0" title="0">{
                                idx := m.preflight.visibleIdx[m.preflight.listIndex]
                                st := m.preflight.items[idx].Story
                                if st.IsFolder </span><span class="cov0" title="0">{
                                        m.folderCollapsed[st.ID] = false
                                        m.refreshPreflightVisible()
                                        m.updateViewportContent()
                                }</span>
                        }
                }
        case "h":<span class="cov0" title="0">
                // Collapse folder or parent
                if len(m.preflight.items) &gt; 0 &amp;&amp; m.preflight.listIndex &lt; len(m.preflight.items) </span><span class="cov0" title="0">{
                        if m.preflight.listIndex &gt;= 0 &amp;&amp; m.preflight.listIndex &lt; len(m.preflight.visibleIdx) </span><span class="cov0" title="0">{
                                idx := m.preflight.visibleIdx[m.preflight.listIndex]
                                st := m.preflight.items[idx].Story
                                if st.IsFolder </span><span class="cov0" title="0">{
                                        m.folderCollapsed[st.ID] = true
                                        m.refreshPreflightVisible()
                                        m.updateViewportContent()
                                }</span> else<span class="cov0" title="0"> if st.FolderID != nil </span><span class="cov0" title="0">{
                                        pid := *st.FolderID
                                        m.folderCollapsed[pid] = true
                                        m.refreshPreflightVisible()
                                        // Move cursor to parent if visible
                                        for vis, ii := range m.preflight.visibleIdx </span><span class="cov0" title="0">{
                                                if m.preflight.items[ii].Story.ID == pid </span><span class="cov0" title="0">{
                                                        m.preflight.listIndex = vis
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">m.ensurePreflightCursorVisible()
                                        m.updateViewportContent()</span>
                                }
                        }
                }
        case "H":<span class="cov0" title="0">
                // Collapse all folders
                for id := range m.folderCollapsed </span><span class="cov0" title="0">{
                        m.folderCollapsed[id] = true
                }</span>
                <span class="cov0" title="0">m.refreshPreflightVisible()
                m.updateViewportContent()</span>
        case "L":<span class="cov0" title="0">
                // Expand all folders
                for id := range m.folderCollapsed </span><span class="cov0" title="0">{
                        m.folderCollapsed[id] = false
                }</span>
                <span class="cov0" title="0">m.refreshPreflightVisible()
                m.updateViewportContent()</span>
        case "j", "down":<span class="cov0" title="0">
                // Use visible list length
                maxIdx := len(m.preflight.visibleIdx)
                if maxIdx == 0 </span><span class="cov0" title="0">{
                        maxIdx = len(m.preflight.items)
                }</span>
                <span class="cov0" title="0">if m.preflight.listIndex &lt; maxIdx-1 </span><span class="cov0" title="0">{
                        m.preflight.listIndex++
                        m.ensurePreflightCursorVisible()
                        m.updateViewportContent()
                }</span>
        case "k", "up":<span class="cov0" title="0">
                if m.preflight.listIndex &gt; 0 </span><span class="cov0" title="0">{
                        m.preflight.listIndex--
                        m.ensurePreflightCursorVisible()
                        m.updateViewportContent()
                }</span>
        case "ctrl+d", "pgdown":<span class="cov0" title="0">
                jump := m.viewport.Height
                if jump &lt;= 0 </span><span class="cov0" title="0">{
                        jump = 10
                }</span>
                <span class="cov0" title="0">maxIdx := len(m.preflight.visibleIdx)
                if maxIdx == 0 </span><span class="cov0" title="0">{
                        maxIdx = len(m.preflight.items)
                }</span>
                <span class="cov0" title="0">if m.preflight.listIndex+jump &lt; maxIdx </span><span class="cov0" title="0">{
                        m.preflight.listIndex += jump
                }</span> else<span class="cov0" title="0"> {
                        m.preflight.listIndex = maxIdx - 1
                }</span>
                <span class="cov0" title="0">m.ensurePreflightCursorVisible()
                m.updateViewportContent()</span>
        case "ctrl+u", "pgup":<span class="cov0" title="0">
                jump := m.viewport.Height
                if jump &lt;= 0 </span><span class="cov0" title="0">{
                        jump = 10
                }</span>
                <span class="cov0" title="0">if m.preflight.listIndex-jump &gt;= 0 </span><span class="cov0" title="0">{
                        m.preflight.listIndex -= jump
                }</span> else<span class="cov0" title="0"> {
                        m.preflight.listIndex = 0
                }</span>
                <span class="cov0" title="0">m.ensurePreflightCursorVisible()
                m.updateViewportContent()</span>
        case "x":<span class="cov8" title="1">
                if len(m.preflight.items) &gt; 0 </span><span class="cov8" title="1">{
                        it := &amp;m.preflight.items[m.preflight.listIndex]
                        if it.Collision &amp;&amp; it.Selected </span><span class="cov8" title="1">{
                                it.Skip = !it.Skip
                                it.RecalcState()
                                m.updateViewportContent()
                        }</span>
                }
        case "X":<span class="cov8" title="1">
                for i := range m.preflight.items </span><span class="cov8" title="1">{
                        if m.preflight.items[i].Collision &amp;&amp; m.preflight.items[i].Selected </span><span class="cov8" title="1">{
                                m.preflight.items[i].Skip = true
                                m.preflight.items[i].RecalcState()
                        }</span>
                }
                <span class="cov8" title="1">m.updateViewportContent()</span>
        case "c":<span class="cov8" title="1">
                removed := false
                for _, it := range m.preflight.items </span><span class="cov8" title="1">{
                        if it.Skip </span><span class="cov8" title="1">{
                                delete(m.selection.selected, it.Story.FullSlug)
                                removed = true
                        }</span>
                }
                <span class="cov8" title="1">if removed </span><span class="cov8" title="1">{
                        m.startPreflight()
                }</span>
        case "esc", "q":<span class="cov8" title="1">
                // restore browse collapse state
                if m.collapsedBeforePreflight != nil </span><span class="cov8" title="1">{
                        for id := range m.folderCollapsed </span><span class="cov0" title="0">{
                                if prev, ok := m.collapsedBeforePreflight[id]; ok </span><span class="cov0" title="0">{
                                        m.folderCollapsed[id] = prev
                                }</span>
                        }
                        <span class="cov8" title="1">m.collapsedBeforePreflight = nil</span>
                }
                <span class="cov8" title="1">m.refreshVisible()
                m.state = stateBrowseList
                m.updateViewportContent()
                return m, nil</span>
        case "enter":<span class="cov0" title="0">
                m.optimizePreflight()
                if len(m.preflight.items) == 0 </span><span class="cov0" title="0">{
                        m.statusMsg = "Keine Items zum Sync"
                        return m, nil
                }</span>
                <span class="cov0" title="0">m.plan = SyncPlan{Items: append([]PreflightItem(nil), m.preflight.items...)}
                m.syncing = true
                m.syncIndex = 0
                m.api = sb.New(m.cfg.Token)
                m.state = stateSync

                // Set up cancellation context for sync operations
                m.syncContext, m.syncCancel = context.WithCancel(context.Background())

                // Initialize comprehensive report with space information
                sourceSpaceName := ""
                targetSpaceName := ""
                if m.sourceSpace != nil </span><span class="cov0" title="0">{
                        sourceSpaceName = fmt.Sprintf("%s (%d)", m.sourceSpace.Name, m.sourceSpace.ID)
                }</span>
                <span class="cov0" title="0">if m.targetSpace != nil </span><span class="cov0" title="0">{
                        targetSpaceName = fmt.Sprintf("%s (%d)", m.targetSpace.Name, m.targetSpace.ID)
                }</span>
                <span class="cov0" title="0">m.report = *NewReport(sourceSpaceName, targetSpaceName)

                m.statusMsg = fmt.Sprintf("Synchronisiere %d Items…", len(m.preflight.items))
                return m, tea.Batch(m.spinner.Tick, m.runNextItem())</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

func (m *Model) startPreflight() <span class="cov8" title="1">{
        target := make(map[string]bool, len(m.storiesTarget))
        for _, st := range m.storiesTarget </span><span class="cov8" title="1">{
                target[st.FullSlug] = true
        }</span>
        <span class="cov8" title="1">included := make(map[int]bool)
        for slug, v := range m.selection.selected </span><span class="cov8" title="1">{
                if !v </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if idx := m.indexBySlug(slug); idx &gt;= 0 </span><span class="cov8" title="1">{
                        m.includeAncestors(idx, included)
                }</span>
        }
        <span class="cov8" title="1">if len(included) == 0 </span><span class="cov8" title="1">{
                m.preflight = PreflightState{}
                m.statusMsg = "Keine Stories markiert."
                return
        }</span>
        <span class="cov8" title="1">children := make(map[int][]int)
        roots := make([]int, 0)
        for i, st := range m.storiesSource </span><span class="cov8" title="1">{
                if !included[i] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if st.FolderID != nil </span><span class="cov8" title="1">{
                        if pIdx, ok := m.storyIdx[*st.FolderID]; ok &amp;&amp; included[pIdx] </span><span class="cov8" title="1">{
                                children[pIdx] = append(children[pIdx], i)
                                continue</span>
                        }
                }
                <span class="cov8" title="1">roots = append(roots, i)</span>
        }
        <span class="cov8" title="1">items := make([]PreflightItem, 0, len(included))
        var walk func(int)
        walk = func(idx int) </span><span class="cov8" title="1">{
                st := m.storiesSource[idx]
                sel := m.selection.selected[st.FullSlug]
                it := PreflightItem{Story: st, Collision: target[st.FullSlug], Selected: sel, Skip: !sel}
                it.RecalcState()
                items = append(items, it)
                for _, ch := range children[idx] </span><span class="cov8" title="1">{
                        walk(ch)
                }</span>
        }
        <span class="cov8" title="1">for _, r := range roots </span><span class="cov8" title="1">{
                walk(r)
        }</span>
        // Initialize preflight state; preflight view should start fully expanded.
        // We'll build visibleIdx like browse does, using current folderCollapsed but ensure all expanded at start.
        // Save previous collapse state to restore later if needed.
        // preserve previous collapse state and start preflight fully expanded
        <span class="cov8" title="1">m.collapsedBeforePreflight = make(map[int]bool, len(m.folderCollapsed))
        for id, v := range m.folderCollapsed </span><span class="cov8" title="1">{
                m.collapsedBeforePreflight[id] = v
        }</span>
        <span class="cov8" title="1">for id := range m.folderCollapsed </span><span class="cov8" title="1">{
                m.folderCollapsed[id] = false
        }</span>

        <span class="cov8" title="1">m.preflight = PreflightState{items: items, listIndex: 0}
        m.refreshPreflightVisible()
        m.state = statePreflight
        collisions := 0
        for _, it := range items </span><span class="cov8" title="1">{
                if it.Collision </span><span class="cov8" title="1">{
                        collisions++
                }</span>
        }
        <span class="cov8" title="1">m.statusMsg = fmt.Sprintf("Preflight: %d Items, %d Kollisionen", len(items), collisions)
        m.updateViewportContent()</span>
}

func (m *Model) ensurePreflightCursorVisible() <span class="cov8" title="1">{
        n := len(m.preflight.items)
        if n == 0 </span><span class="cov0" title="0">{
                m.preflight.listIndex = 0
                return
        }</span>
        <span class="cov8" title="1">if m.preflight.listIndex &lt; 0 </span><span class="cov0" title="0">{
                m.preflight.listIndex = 0
        }</span>
        <span class="cov8" title="1">if m.preflight.listIndex &gt; n-1 </span><span class="cov0" title="0">{
                m.preflight.listIndex = n - 1
        }</span>
        // Calculate which line in the viewport content the cursor is on
        <span class="cov8" title="1">cursorLine := m.calculatePreflightCursorLine()

        // Adjust viewport using shared helper
        m.ensureCursorInViewport(cursorLine)</span>
}

func (m *Model) calculatePreflightCursorLine() int <span class="cov8" title="1">{
        // Match renderPreflightContent exactly, including wrapping
        total := len(m.preflight.items)
        if total == 0 || m.preflight.listIndex &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Visible order and stories via shared helper
        <span class="cov8" title="1">stories, order := m.visibleOrderPreflight()
        treeLines := generateTreeLinesFromStories(stories)

        // Width budget equals renderPreflightContent (cursorCell + stateCell + content)
        contentWidth := m.width - 4
        if contentWidth &lt;= 0 </span><span class="cov8" title="1">{
                contentWidth = 80
        }</span>

        // Sum wrapped lines up to the cursor's visible position (exclusive)
        <span class="cov8" title="1">sum := 0
        max := m.preflight.listIndex
        if max &gt; len(order) </span><span class="cov0" title="0">{
                max = len(order)
        }</span>
        <span class="cov8" title="1">for visPos := 0; visPos &lt; max; visPos++ </span><span class="cov8" title="1">{
                if visPos &gt;= len(treeLines) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">idx := order[visPos]
                it := m.preflight.items[idx]

                // Recreate exact content prefix (collision sign/padding)
                content := treeLines[visPos]
                if it.Collision </span><span class="cov0" title="0">{
                        content = collisionSign + " " + content
                }</span> else<span class="cov8" title="1"> {
                        content = "  " + content
                }</span>

                // Apply same styling (without cursor highlight)
                <span class="cov8" title="1">lineStyle := lipgloss.NewStyle().Width(contentWidth)
                if it.State == StateSkip </span><span class="cov0" title="0">{
                        lineStyle = lineStyle.Faint(true)
                }</span>
                <span class="cov8" title="1">styled := lineStyle.Render(content)
                sum += m.countWrappedLines(styled)</span>
        }
        <span class="cov8" title="1">return sum</span>
}

// refreshPreflightVisible builds visibleIdx for preflight items based on folderCollapsed
func (m *Model) refreshPreflightVisible() <span class="cov8" title="1">{
        // Construct children map using storiesSource relationships for consistent IDs
        children := make(map[int][]int)
        for pi, it := range m.preflight.items </span><span class="cov8" title="1">{
                st := it.Story
                if st.FolderID != nil </span><span class="cov8" title="1">{
                        children[*st.FolderID] = append(children[*st.FolderID], pi)
                }</span>
        }

        <span class="cov8" title="1">m.preflight.visibleIdx = m.preflight.visibleIdx[:0]

        var addVisible func(int)
        addVisible = func(idx int) </span><span class="cov8" title="1">{
                st := m.preflight.items[idx].Story
                m.preflight.visibleIdx = append(m.preflight.visibleIdx, idx)
                if st.IsFolder &amp;&amp; !m.folderCollapsed[st.ID] </span><span class="cov8" title="1">{
                        for _, ch := range children[st.ID] </span><span class="cov8" title="1">{
                                addVisible(ch)
                        }</span>
                }
        }

        <span class="cov8" title="1">for i, it := range m.preflight.items </span><span class="cov8" title="1">{
                if it.Story.FolderID == nil </span><span class="cov8" title="1">{
                        addVisible(i)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package ui

import (
        "fmt"

        tea "github.com/charmbracelet/bubbletea"

        "storyblok-sync/internal/sb"
)

func (m Model) handleReportKey(key string) (Model, tea.Cmd) <span class="cov0" title="0">{
        switch key </span>{
        case "enter":<span class="cov0" title="0">
                // Go back to scan screen to allow starting a new sync
                m.state = stateScanning
                m.statusMsg = "Returning to scan screen for new sync…"
                return m, m.scanStoriesCmd()</span>
        case "r":<span class="cov0" title="0">
                // Retry failures - rebuild preflight with only failed items
                if m.report.Summary.Failure &gt; 0 </span><span class="cov0" title="0">{
                        failedItems := m.getFailedItemsForRetry()
                        if len(failedItems) &gt; 0 </span><span class="cov0" title="0">{
                                m.preflight.items = failedItems
                                m.preflight.listIndex = 0
                                m.state = statePreflight
                                m.statusMsg = fmt.Sprintf("Retry: %d failed items ready for sync", len(failedItems))
                                return m, nil
                        }</span>
                }
                // If no failures or couldn't build retry list, just stay on report
                <span class="cov0" title="0">m.statusMsg = "No failures to retry"
                return m, nil</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

// getFailedItemsForRetry creates preflight items from failed report entries
func (m Model) getFailedItemsForRetry() []PreflightItem <span class="cov0" title="0">{
        var failedItems []PreflightItem

        // Build a map of source stories by slug for quick lookup
        sourceMap := make(map[string]sb.Story)
        for _, story := range m.storiesSource </span><span class="cov0" title="0">{
                sourceMap[story.FullSlug] = story
        }</span>

        // Build target stories map for collision detection
        <span class="cov0" title="0">targetMap := make(map[string]bool)
        for _, story := range m.storiesTarget </span><span class="cov0" title="0">{
                targetMap[story.FullSlug] = true
        }</span>

        // Create preflight items for each failed entry
        <span class="cov0" title="0">for _, entry := range m.report.Entries </span><span class="cov0" title="0">{
                if entry.Status == "failure" </span><span class="cov0" title="0">{
                        if sourceStory, exists := sourceMap[entry.Slug]; exists </span><span class="cov0" title="0">{
                                item := PreflightItem{
                                        Story:     sourceStory,
                                        Collision: targetMap[entry.Slug],
                                        Skip:      false,
                                        Selected:  true, // Auto-select failed items for retry
                                        Run:       RunPending,
                                }
                                item.RecalcState()
                                failedItems = append(failedItems, item)
                        }</span>
                }
        }

        <span class="cov0" title="0">return failedItems</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ui

import (
        "fmt"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
)

// ---------- Setup Screen Handlers ----------

func (m Model) handleWelcomeKey(key string) (Model, tea.Cmd) <span class="cov8" title="1">{
        switch key </span>{
        case "enter":<span class="cov8" title="1">
                if m.cfg.Token == "" </span><span class="cov8" title="1">{
                        m.state = stateTokenPrompt
                        m.statusMsg = "Bitte gib deinen Token ein."
                        return m, nil
                }</span>
                <span class="cov8" title="1">m.state = stateValidating
                m.statusMsg = "Validiere Token…"
                return m, tea.Batch(m.spinner.Tick, m.validateTokenCmd())</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (m Model) handleTokenPromptKey(msg tea.KeyMsg) (Model, tea.Cmd) <span class="cov0" title="0">{
        key := msg.String()
        switch key </span>{
        case "esc":<span class="cov0" title="0">
                m.state = stateWelcome
                m.statusMsg = "Zurück zum Welcome."
                return m, nil</span>
        case "enter":<span class="cov0" title="0">
                m.cfg.Token = strings.TrimSpace(m.ti.Value())
                if m.cfg.Token == "" </span><span class="cov0" title="0">{
                        m.statusMsg = "Token leer."
                        return m, nil
                }</span>
                <span class="cov0" title="0">m.state = stateValidating
                m.statusMsg = "Validiere Token…"
                return m, tea.Batch(m.spinner.Tick, m.validateTokenCmd())</span>
        default:<span class="cov0" title="0">
                var cmd tea.Cmd
                m.ti, cmd = m.ti.Update(msg)
                return m, cmd</span>
        }
}

func (m Model) handleValidatingKey(key string) (Model, tea.Cmd) <span class="cov0" title="0">{
        return m, nil
}</span>

func (m Model) handleSpaceSelectKey(key string) (Model, tea.Cmd) <span class="cov0" title="0">{
        switch key </span>{
        case "j", "down":<span class="cov0" title="0">
                if m.selectedIndex &lt; len(m.spaces)-1 </span><span class="cov0" title="0">{
                        m.selectedIndex++
                }</span>
        case "k", "up":<span class="cov0" title="0">
                if m.selectedIndex &gt; 0 </span><span class="cov0" title="0">{
                        m.selectedIndex--
                }</span>
        case "enter":<span class="cov0" title="0">
                if len(m.spaces) == 0 </span><span class="cov0" title="0">{
                        return m, nil
                }</span>
                <span class="cov0" title="0">chosen := m.spaces[m.selectedIndex]
                if m.selectingSource </span><span class="cov0" title="0">{
                        // Source wählen; Target-Auswahl vorbereiten
                        m.sourceSpace = &amp;chosen
                        m.selectingSource = false
                        // optional: Target nicht gleich Source erlauben?
                        // wir lassen es erstmal zu; man kann später coden, dass source!=target sein muss.
                        m.statusMsg = fmt.Sprintf("Source gesetzt: %s (%d). Wähle jetzt Target.", chosen.Name, chosen.ID)
                        // Reset index für Target-Auswahl
                        m.selectedIndex = 0
                }</span> else<span class="cov0" title="0"> {
                        m.targetSpace = &amp;chosen
                        m.statusMsg = fmt.Sprintf("Target gesetzt: %s (%d). Scanne jetzt Stories…", chosen.Name, chosen.ID)
                        m.state = stateScanning
                        return m, tea.Batch(m.spinner.Tick, m.scanStoriesCmd())
                }</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (m Model) handleScanningKey(key string) (Model, tea.Cmd) <span class="cov0" title="0">{
        // Platzhalter – später starten wir hier den echten Scan und wechseln nach BrowseList.
        return m, nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package ui

import (
        tea "github.com/charmbracelet/bubbletea"
)

func (m Model) handleSyncKey(key string) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch key </span>{
        case "ctrl+c":<span class="cov0" title="0">
                if m.syncCancel != nil </span><span class="cov0" title="0">{
                        m.syncCancel() // Cancel the sync context
                }</span>
                <span class="cov0" title="0">m.syncing = false
                m.statusMsg = "Synchronisation abgebrochen"
                return m, nil</span>
        }

        // During sync, most keys are ignored to prevent user interference
        // The sync process is controlled by commands, not key presses
        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ui

import (
        "storyblok-sync/internal/config"

        "github.com/charmbracelet/bubbles/spinner"
        "github.com/charmbracelet/bubbles/textinput"
        "github.com/charmbracelet/bubbles/viewport"
        tea "github.com/charmbracelet/bubbletea"
)

func InitialModel() Model <span class="cov8" title="1">{
        p := config.DefaultPath()
        cfg, err := config.Load(p)
        hasFile := err == nil

        m := Model{
                state:     stateWelcome,
                cfg:       cfg,
                hasSBRC:   hasFile,
                sbrcPath:  p,
                statusMsg: "",
        }

        if cfg.Token == "" </span><span class="cov0" title="0">{
                m.statusMsg = "Keine ~/.sbrc oder kein Token – drück Enter für Token-Eingabe."
        }</span> else<span class="cov8" title="1"> {
                m.statusMsg = "Token gefunden – Enter zum Validieren, q zum Beenden."
        }</span>

        // textinput
        <span class="cov8" title="1">ti := textinput.New()
        ti.Placeholder = "Storyblok Personal Access Token"
        ti.Focus()
        ti.EchoMode = textinput.EchoPassword
        ti.CharLimit = 200
        m.ti = ti
        m.selection.selected = make(map[string]bool)
        m.folderCollapsed = make(map[int]bool)
        m.storyIdx = make(map[int]int)

        // search
        si := textinput.New()
        si.Placeholder = "Fuzzy suchen…"
        si.CharLimit = 200
        si.Width = 40
        m.search.searchInput = si
        m.search.query = ""
        m.search.filteredIdx = nil
        m.filterCfg = FilterConfig{
                MinCoverage: 0.6, // strenger -&gt; höher (z.B. 0.7)
                MaxSpread:   40,  // strenger -&gt; kleiner (z.B. 25)
                MaxResults:  200, // UI ruhig halten
        }

        // prefix
        pi := textinput.New()
        pi.Placeholder = "Slug-Prefix (z.B. a__portal/de)"
        pi.CharLimit = 200
        pi.Width = 40
        m.filter.prefixInput = pi
        m.filter.prefix = ""

        // spinner
        sp := spinner.New()
        sp.Spinner = spinner.Line
        sp.Style = subtleStyle
        m.spinner = sp

        // viewport
        vp := viewport.New(80, 24) // initial dimensions, will be updated in WindowSize
        m.viewport = vp

        return m</span>
}

func (m Model) Init() tea.Cmd <span class="cov0" title="0">{ return nil }</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package ui

import (
        "context"
        "fmt"
        "time"

        tea "github.com/charmbracelet/bubbletea"

        "storyblok-sync/internal/sb"
)

// ---------- Messages / Cmds ----------
type validateMsg struct {
        spaces []sb.Space
        err    error
}

type scanMsg struct {
        src []sb.Story
        tgt []sb.Story
        err error
}

func (m Model) validateTokenCmd() tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                defer cancel()
                c := sb.New(m.cfg.Token)
                spaces, err := c.ListSpaces(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return validateMsg{err: err}
                }</span>
                <span class="cov0" title="0">return validateMsg{spaces: spaces, err: nil}</span>
        }
}

func (m Model) scanStoriesCmd() tea.Cmd <span class="cov0" title="0">{
        srcID, tgtID := 0, 0
        if m.sourceSpace != nil </span><span class="cov0" title="0">{
                srcID = m.sourceSpace.ID
        }</span>
        <span class="cov0" title="0">if m.targetSpace != nil </span><span class="cov0" title="0">{
                tgtID = m.targetSpace.ID
        }</span>
        <span class="cov0" title="0">token := m.cfg.Token

        return func() tea.Msg </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                defer cancel()
                c := sb.New(token)

                // Parallel wäre nice-to-have, hier sequentiell für Klarheit
                src, err := c.ListStories(ctx, sb.ListStoriesOpts{SpaceID: srcID, PerPage: 50})
                if err != nil </span><span class="cov0" title="0">{
                        return scanMsg{err: fmt.Errorf("source scan: %w", err)}
                }</span>
                <span class="cov0" title="0">sortStories(src)
                tgt, err := c.ListStories(ctx, sb.ListStoriesOpts{SpaceID: tgtID, PerPage: 50})
                if err != nil </span><span class="cov0" title="0">{
                        return scanMsg{err: fmt.Errorf("target scan: %w", err)}
                }</span>
                <span class="cov0" title="0">sortStories(tgt)
                return scanMsg{src: src, tgt: tgt, err: nil}</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package ui

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "sort"
        "time"

        "storyblok-sync/internal/sb"
)

// ReportEntry captures the result of a single sync item with comprehensive details.
type ReportEntry struct {
        Slug        string    `json:"slug"`
        Status      string    `json:"status"`              // success|warning|failure
        Operation   string    `json:"operation,omitempty"` // create|update|skip
        Error       string    `json:"error,omitempty"`
        Warning     string    `json:"warning,omitempty"`
        Duration    int64     `json:"duration_ms,omitempty"`  // Duration in milliseconds
        Story       *sb.Story `json:"source_story,omitempty"` // Complete source story for errors/warnings
        TargetStory *sb.Story `json:"target_story,omitempty"` // Target story if created/updated
}

// Report collects all entries and provides comprehensive sync reporting.
type Report struct {
        StartTime   time.Time     `json:"start_time"`
        EndTime     time.Time     `json:"end_time,omitempty"`
        Duration    int64         `json:"total_duration_ms,omitempty"`
        SourceSpace string        `json:"source_space,omitempty"`
        TargetSpace string        `json:"target_space,omitempty"`
        Entries     []ReportEntry `json:"entries"`
        Summary     ReportSummary `json:"summary"`
}

// ReportSummary provides aggregate statistics
type ReportSummary struct {
        Total   int `json:"total"`
        Success int `json:"success"`
        Warning int `json:"warning"`
        Failure int `json:"failure"`
        Created int `json:"created"`
        Updated int `json:"updated"`
        Skipped int `json:"skipped"`
}

// NewReport creates a new report with initial metadata
func NewReport(sourceSpace, targetSpace string) *Report <span class="cov8" title="1">{
        return &amp;Report{
                StartTime:   time.Now(),
                SourceSpace: sourceSpace,
                TargetSpace: targetSpace,
                Entries:     make([]ReportEntry, 0),
        }
}</span>

// Add adds an entry to the report
func (r *Report) Add(e ReportEntry) <span class="cov8" title="1">{
        r.Entries = append(r.Entries, e)
}</span>

// AddSuccess adds a successful sync entry
func (r *Report) AddSuccess(slug, operation string, duration int64, targetStory *sb.Story) <span class="cov8" title="1">{
        r.Add(ReportEntry{
                Slug:        slug,
                Status:      "success",
                Operation:   operation,
                Duration:    duration,
                TargetStory: targetStory,
        })
}</span>

// AddWarning adds a warning entry with complete source story
func (r *Report) AddWarning(slug, operation, warning string, duration int64, sourceStory, targetStory *sb.Story) <span class="cov8" title="1">{
        r.Add(ReportEntry{
                Slug:        slug,
                Status:      "warning",
                Operation:   operation,
                Warning:     warning,
                Duration:    duration,
                Story:       sourceStory,
                TargetStory: targetStory,
        })
}</span>

// AddError adds an error entry with complete source story
func (r *Report) AddError(slug, operation, error string, duration int64, sourceStory *sb.Story) <span class="cov8" title="1">{
        r.Add(ReportEntry{
                Slug:      slug,
                Status:    "failure",
                Operation: operation,
                Error:     error,
                Duration:  duration,
                Story:     sourceStory,
        })
}</span>

// Finalize calculates final statistics and duration
func (r *Report) Finalize() <span class="cov8" title="1">{
        r.EndTime = time.Now()
        r.Duration = r.EndTime.Sub(r.StartTime).Milliseconds()
        r.calculateSummary()
}</span>

// calculateSummary computes the report summary statistics
func (r *Report) calculateSummary() <span class="cov8" title="1">{
        summary := ReportSummary{}

        for _, e := range r.Entries </span><span class="cov8" title="1">{
                summary.Total++

                switch e.Status </span>{
                case "success":<span class="cov8" title="1">
                        summary.Success++</span>
                case "warning":<span class="cov8" title="1">
                        summary.Warning++</span>
                case "failure":<span class="cov8" title="1">
                        summary.Failure++</span>
                }

                <span class="cov8" title="1">switch e.Operation </span>{
                case "create":<span class="cov8" title="1">
                        summary.Created++</span>
                case "update":<span class="cov8" title="1">
                        summary.Updated++</span>
                case "skip":<span class="cov0" title="0">
                        summary.Skipped++</span>
                }
        }

        <span class="cov8" title="1">r.Summary = summary</span>
}

// Counts returns the count of success, warning, and failure entries (for backward compatibility)
func (r *Report) Counts() (success, warning, failure int) <span class="cov8" title="1">{
        for _, e := range r.Entries </span><span class="cov8" title="1">{
                switch e.Status </span>{
                case "success":<span class="cov8" title="1">
                        success++</span>
                case "warning":<span class="cov8" title="1">
                        warning++</span>
                case "failure":<span class="cov8" title="1">
                        failure++</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// GetDisplaySummary returns a German summary string for UI display
func (r *Report) GetDisplaySummary() string <span class="cov8" title="1">{
        r.calculateSummary()
        return fmt.Sprintf("%d Erfolge, %d Warnungen, %d Fehler",
                r.Summary.Success, r.Summary.Warning, r.Summary.Failure)
}</span>

// Save writes the comprehensive report to a JSON file in the current directory.
// It also performs cleanup of old report files to prevent disk space accumulation.
func (r *Report) Save() error <span class="cov8" title="1">{
        r.Finalize()

        if len(r.Entries) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Clean up old report files before creating a new one
        <span class="cov8" title="1">if err := r.cleanupOldReports(); err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail the save operation
                log.Printf("Warning: failed to cleanup old reports: %v", err)
        }</span>

        <span class="cov8" title="1">data, err := json.MarshalIndent(r, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">filename := fmt.Sprintf("sync-report-%s.json", time.Now().Format("20060102-150405"))
        return os.WriteFile(filename, data, 0o644)</span>
}

// cleanupOldReports removes old report files, keeping only the most recent 10 files
func (r *Report) cleanupOldReports() error <span class="cov8" title="1">{
        files, err := filepath.Glob("sync-report-*.json")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find report files: %w", err)
        }</span>

        // Keep only the most recent 10 reports
        <span class="cov8" title="1">if len(files) &lt;= 10 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Sort files by name (which includes timestamp, so this sorts by date)
        <span class="cov8" title="1">sort.Strings(files)

        // Remove the oldest files, keeping the last 10
        filesToRemove := files[:len(files)-10]
        for _, file := range filesToRemove </span><span class="cov8" title="1">{
                if err := os.Remove(file); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to remove old report file %s: %v", file, err)
                }</span>
        }

        <span class="cov8" title="1">if len(filesToRemove) &gt; 0 </span><span class="cov8" title="1">{
                log.Printf("Cleaned up %d old report files", len(filesToRemove))
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package ui

import (
        "sort"
        "strings"

        "storyblok-sync/internal/sb"
)

// sortStories orders the slice so that folders come first, followed by root stories
// (startpages) and finally regular stories. Items of the same type are sorted by
// their display name in a case-insensitive manner.
func sortStories(stories []sb.Story) <span class="cov8" title="1">{
        sort.SliceStable(stories, func(i, j int) bool </span><span class="cov8" title="1">{
                a, b := stories[i], stories[j]
                pa, pb := sortPriority(a), sortPriority(b)
                if pa != pb </span><span class="cov8" title="1">{
                        return pa &lt; pb
                }</span>
                <span class="cov8" title="1">na := strings.ToLower(displayName(a))
                nb := strings.ToLower(displayName(b))
                return na &lt; nb</span>
        })
}

func sortPriority(st sb.Story) int <span class="cov8" title="1">{
        switch </span>{
        case st.IsFolder:<span class="cov8" title="1">
                return 0</span>
        case st.IsStartpage:<span class="cov8" title="1">
                return 1</span>
        default:<span class="cov8" title="1">
                return 2</span>
        }
}

func displayName(st sb.Story) string <span class="cov8" title="1">{
        if st.Name != "" </span><span class="cov8" title="1">{
                return st.Name
        }</span>
        <span class="cov0" title="0">return st.Slug</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package ui

import (
        "strings"

        "github.com/charmbracelet/lipgloss"
)

// --- UI Styles ---
var (
        titleStyle      = lipgloss.NewStyle().Bold(true).Underline(true).Foreground(lipgloss.Color("#8942E1"))
        subtitleStyle   = lipgloss.NewStyle().Foreground(lipgloss.Color("#3AC4BA")).Italic(true)
        subtleStyle     = lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
        okStyle         = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#10B981"))
        warnStyle       = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#F59E0B"))
        errorStyle      = lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color("#EF4444"))
        helpStyle       = lipgloss.NewStyle().Foreground(lipgloss.Color("245")).Italic(true)
        welcomeBoxStyle = lipgloss.NewStyle().
                        Border(lipgloss.RoundedBorder()).
                        BorderForeground(lipgloss.Color("#8942E1")).
                        Padding(1, 2).
                        Margin(1, 0)
        centeredStyle   = lipgloss.NewStyle().Align(lipgloss.Center)
        listHeaderStyle = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#8942E1")).
                        Margin(0, 0, 1, 0)
        spaceItemStyle = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("252")).
                        Padding(0, 1)
        spaceSelectedStyle = lipgloss.NewStyle().
                                Bold(true).
                                Foreground(lipgloss.Color("#FFFFFF")).
                                Background(lipgloss.Color("#8942E1")).
                                Padding(0, 1)
        dividerStyle     = lipgloss.NewStyle().Foreground(lipgloss.Color("240"))
        focusStyle       = lipgloss.NewStyle().Bold(true)
        cursorLineStyle  = lipgloss.NewStyle().Background(lipgloss.Color("#2A2B3D"))
        cursorBarStyle   = lipgloss.NewStyle().Background(lipgloss.Color("#FFAB78"))
        markBarStyle     = lipgloss.NewStyle().Background(lipgloss.Color("#3AC4BA"))
        markNestedStyle  = lipgloss.NewStyle().Foreground(lipgloss.Color("#3AC4BA"))
        collisionSign    = lipgloss.NewStyle().Foreground(lipgloss.Color("11")).Render("!")
        stateCreateStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("10"))
        stateUpdateStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("11"))
        stateSkipStyle   = lipgloss.NewStyle().Foreground(lipgloss.Color("245"))
        stateDoneStyle   = lipgloss.NewStyle().Background(lipgloss.Color("10")).Foreground(lipgloss.Color("0")).Bold(true)

        // markers for different story types (colored squares)
        symbolStory  = fgSymbol("#8942E1", "S")
        symbolFolder = fgSymbol("#3AC4BA", "F")
        symbolRoot   = fgSymbol("214", "R")
)

var stateStyles = map[SyncState]lipgloss.Style{
        StateCreate: stateCreateStyle,
        StateUpdate: stateUpdateStyle,
        StateSkip:   stateSkipStyle,
}

func fgSymbol(col, ch string) string <span class="cov8" title="1">{
        s := lipgloss.NewStyle().Foreground(lipgloss.Color(col)).Render(ch)
        const reset = "\x1b[0m"
        return strings.TrimSuffix(s, reset) + "\x1b[39m"
}</span>

// renderFooter creates a consistent footer across all views
// statusLine: optional status information (shown in subtleStyle)
// helpLines: help text lines (shown in helpStyle)
func renderFooter(statusLine string, helpLines ...string) string <span class="cov8" title="1">{
        var b strings.Builder

        if statusLine != "" </span><span class="cov0" title="0">{
                b.WriteString(subtleStyle.Render(statusLine) + "\n")
        }</span>

        <span class="cov8" title="1">for _, line := range helpLines </span><span class="cov8" title="1">{
                b.WriteString(helpStyle.Render(line) + "\n")
        }</span>

        // Remove trailing newline
        <span class="cov8" title="1">result := b.String()
        return strings.TrimSuffix(result, "\n")</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package ui

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strings"
        "time"

        tea "github.com/charmbracelet/bubbletea"

        "storyblok-sync/internal/sb"
        "storyblok-sync/internal/ui/sync"
)

// Constants for sync operations and timeouts
const (
        // API timeout constants
        defaultTimeout = 15 * time.Second
        longTimeout    = 30 * time.Second

        // Operation types - use sync package constants
        operationCreate = sync.OperationCreate
        operationUpdate = sync.OperationUpdate
        operationSkip   = sync.OperationSkip
)

// Legacy wrapper for content management - now uses the extracted module
type contentManager struct {
        *sync.ContentManager
}

// newContentManager creates a new content manager using the extracted module
func newContentManager(api folderAPI, spaceID int) *contentManager <span class="cov8" title="1">{
        return &amp;contentManager{
                ContentManager: sync.NewContentManager(api, spaceID),
        }
}</span>

// ensureContent is a legacy wrapper that calls the new EnsureContent method
func (cm *contentManager) ensureContent(ctx context.Context, story sb.Story) (sb.Story, error) <span class="cov8" title="1">{
        return cm.EnsureContent(ctx, story)
}</span>

// Legacy wrappers for utility functions - now uses the extracted module
func prepareStoryForCreation(story sb.Story) sb.Story <span class="cov8" title="1">{
        return sync.PrepareStoryForCreation(story)
}</span>

func prepareStoryForUpdate(source, target sb.Story) sb.Story <span class="cov0" title="0">{
        return sync.PrepareStoryForUpdate(source, target)
}</span>

// resolveParentFolder resolves and sets the correct parent folder ID for a story
func (m *Model) resolveParentFolder(ctx context.Context, story sb.Story) (sb.Story, string, error) <span class="cov0" title="0">{
        var warning string

        if story.FolderID == nil </span><span class="cov0" title="0">{
                return story, warning, nil
        }</span>

        <span class="cov0" title="0">parentSlugStr := sync.ParentSlug(story.FullSlug)
        if parentSlugStr == "" </span><span class="cov0" title="0">{
                story.FolderID = nil
                return story, warning, nil
        }</span>

        <span class="cov0" title="0">targetParents, err := m.api.GetStoriesBySlug(ctx, m.targetSpace.ID, parentSlugStr)
        if err != nil </span><span class="cov0" title="0">{
                return story, warning, err
        }</span>

        <span class="cov0" title="0">if len(targetParents) &gt; 0 </span><span class="cov0" title="0">{
                story.FolderID = &amp;targetParents[0].ID
        }</span> else<span class="cov0" title="0"> {
                story.FolderID = nil
                warning = "Parent folder not found in target space"
        }</span>

        <span class="cov0" title="0">return story, warning, nil</span>
}

// syncUUID updates the UUID of a target story if it differs from source
func (m *Model) syncUUID(ctx context.Context, targetStory sb.Story, sourceUUID string) error <span class="cov0" title="0">{
        if targetStory.UUID == sourceUUID || sourceUUID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">log.Printf("DEBUG: Updating UUID for %s from %s to %s",
                targetStory.FullSlug, targetStory.UUID, sourceUUID)

        err := m.api.UpdateStoryUUID(ctx, m.targetSpace.ID, targetStory.ID, sourceUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to update UUID for story %s: %v", targetStory.FullSlug, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ensureDefaultContent(story sb.Story) sb.Story <span class="cov0" title="0">{
        return sync.EnsureDefaultContent(story)
}</span>

// Legacy type aliases for backward compatibility
type syncItemResult = sync.SyncItemResult
type syncResultMsg = sync.SyncResultMsg
type syncCancelledMsg = sync.SyncCancelledMsg

// Legacy wrapper for logging functions - now uses the extracted module
func logError(operation, slug string, err error, story *sb.Story) <span class="cov0" title="0">{
        sync.LogError(operation, slug, err, story)
}</span>

func logWarning(operation, slug, warning string, story *sb.Story) <span class="cov0" title="0">{
        sync.LogWarning(operation, slug, warning, story)
}</span>

func logSuccess(operation, slug string, duration int64, targetStory *sb.Story) <span class="cov0" title="0">{
        sync.LogSuccess(operation, slug, duration, targetStory)
}</span>

// logExtendedErrorContext is now handled within the sync.LogError function

func getFolderPaths(slug string) []string <span class="cov0" title="0">{
        return sync.GetFolderPaths(slug)
}</span>

// buildTargetFolderMap creates a map of existing folders in target space for quick lookup
func (m *Model) buildTargetFolderMap() map[string]sb.Story <span class="cov0" title="0">{
        planner := sync.NewPreflightPlanner(m.storiesSource, m.storiesTarget)
        return planner.BuildTargetFolderMap()
}</span>

// findMissingFolderPaths analyzes selected items and identifies missing parent folders
func (m *Model) findMissingFolderPaths(items []PreflightItem) map[string]sb.Story <span class="cov0" title="0">{
        planner := sync.NewPreflightPlanner(m.storiesSource, m.storiesTarget)

        // Convert UI PreflightItems to sync PreflightItems
        syncItems := convertToSyncPreflightItems(items)
        missingFolders := planner.FindMissingFolderPaths(syncItems)

        // Convert slice to map for backward compatibility
        folderMap := make(map[string]sb.Story)
        for _, folder := range missingFolders </span><span class="cov0" title="0">{
                folderMap[folder.FullSlug] = folder
        }</span>
        <span class="cov0" title="0">return folderMap</span>
}

// optimizePreflight deduplicates entries, pre-plans missing folders, sorts by sync order (folders first), and merges full folder selections into starts_with tasks.
func (m *Model) optimizePreflight() <span class="cov8" title="1">{
        planner := sync.NewPreflightPlanner(m.storiesSource, m.storiesTarget)

        // Convert UI PreflightItems to sync PreflightItems
        syncItems := convertToSyncPreflightItems(m.preflight.items)
        optimizedSyncItems := planner.OptimizePreflight(syncItems)

        // Convert back to UI PreflightItems
        m.preflight.items = convertFromSyncPreflightItems(optimizedSyncItems)
}</span>

func (m *Model) runNextItem() tea.Cmd <span class="cov0" title="0">{
        if m.syncIndex &gt;= len(m.preflight.items) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">idx := m.syncIndex
        m.preflight.items[idx].Run = RunRunning

        // Create orchestrator for this operation
        reportAdapter := &amp;reportAdapter{report: &amp;m.report}
        orchestrator := sync.NewSyncOrchestrator(m.api, reportAdapter, m.sourceSpace, m.targetSpace)

        // Create a sync item adapter
        item := &amp;preflightItemAdapter{item: m.preflight.items[idx]}

        // Use orchestrator to run the sync operation
        return orchestrator.RunSyncItem(m.syncContext, idx, item)</span>
}

// preflightItemAdapter adapts PreflightItem to sync.SyncItem interface
type preflightItemAdapter struct {
        item PreflightItem
}

func (pia *preflightItemAdapter) GetStory() sb.Story <span class="cov0" title="0">{
        return pia.item.Story
}</span>

func (pia *preflightItemAdapter) IsStartsWith() bool <span class="cov0" title="0">{
        return pia.item.StartsWith
}</span>

func (pia *preflightItemAdapter) IsFolder() bool <span class="cov0" title="0">{
        return pia.item.Story.IsFolder
}</span>

// Legacy wrapper functions for backward compatibility
func isRateLimited(err error) bool <span class="cov0" title="0">{
        return sync.IsRateLimited(err)
}</span>

func isDevModePublishLimit(err error) bool <span class="cov0" title="0">{
        return sync.IsDevModePublishLimit(err)
}</span>

type updateAPI interface {
        UpdateStory(ctx context.Context, spaceID int, st sb.Story, publish bool) (sb.Story, error)
}

type createAPI interface {
        CreateStoryWithPublish(ctx context.Context, spaceID int, st sb.Story, publish bool) (sb.Story, error)
}

// Legacy wrapper functions that now use the extracted API adapters
func updateStoryWithPublishRetry(ctx context.Context, api updateAPI, spaceID int, st sb.Story, publish bool) (sb.Story, error) <span class="cov0" title="0">{
        // TODO: Remove this legacy function completely - now handled by extracted modules
        return api.UpdateStory(ctx, spaceID, st, publish)
}</span>

func createStoryWithPublishRetry(ctx context.Context, api createAPI, spaceID int, st sb.Story, publish bool) (sb.Story, error) <span class="cov0" title="0">{
        // TODO: Remove this legacy function completely - now handled by extracted modules
        return api.CreateStoryWithPublish(ctx, spaceID, st, publish)
}</span>

type folderAPI interface {
        GetStoriesBySlug(ctx context.Context, spaceID int, slug string) ([]sb.Story, error)
        GetStoryWithContent(ctx context.Context, spaceID, storyID int) (sb.Story, error)
        CreateStoryWithPublish(ctx context.Context, spaceID int, st sb.Story, publish bool) (sb.Story, error)
}

// folderPathBuilder handles the creation of folder hierarchies
type folderPathBuilder struct {
        api           folderAPI
        report        *Report
        sourceStories map[string]sb.Story
        contentMgr    *contentManager
        srcSpaceID    int
        tgtSpaceID    int
        publish       bool
}

// newFolderPathBuilder creates a new folder path builder
func newFolderPathBuilder(api folderAPI, report *Report, sourceStories []sb.Story, srcSpaceID, tgtSpaceID int, publish bool) *folderPathBuilder <span class="cov8" title="1">{
        // Build source stories map for quick lookup
        sourceMap := make(map[string]sb.Story)
        for _, story := range sourceStories </span><span class="cov8" title="1">{
                sourceMap[story.FullSlug] = story
        }</span>

        <span class="cov8" title="1">return &amp;folderPathBuilder{
                api:           api,
                report:        report,
                sourceStories: sourceMap,
                contentMgr:    newContentManager(api, srcSpaceID),
                srcSpaceID:    srcSpaceID,
                tgtSpaceID:    tgtSpaceID,
                publish:       publish,
        }</span>
}

// checkExistingFolder checks if a folder exists in the target space
func (fpb *folderPathBuilder) checkExistingFolder(ctx context.Context, path string) (*sb.Story, error) <span class="cov8" title="1">{
        existing, err := fpb.api.GetStoriesBySlug(ctx, fpb.tgtSpaceID, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(existing) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">folder := existing[0]
        log.Printf("DEBUG: Found existing folder: %s (ID: %d)", path, folder.ID)
        return &amp;folder, nil</span>
}

// prepareSourceFolder prepares a source folder for creation in target space
func (fpb *folderPathBuilder) prepareSourceFolder(ctx context.Context, path string, parentID *int) (sb.Story, error) <span class="cov8" title="1">{
        source, exists := fpb.sourceStories[path]
        if !exists </span><span class="cov0" title="0">{
                return sb.Story{}, fmt.Errorf("source folder not found: %s", path)
        }</span>

        // Ensure content is loaded
        <span class="cov8" title="1">folder, err := fpb.contentMgr.ensureContent(ctx, source)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: Failed to fetch content for folder %s: %v", path, err)
                return sb.Story{}, err
        }</span>

        // Prepare for creation
        <span class="cov8" title="1">folder = prepareStoryForCreation(folder)
        folder.FolderID = parentID

        log.Printf("DEBUG: Prepared source folder %s with content: %t", path, len(folder.Content) &gt; 0)
        return folder, nil</span>
}

// createFolder creates a single folder in the target space
func (fpb *folderPathBuilder) createFolder(ctx context.Context, folder sb.Story) (sb.Story, error) <span class="cov8" title="1">{
        log.Printf("DEBUG: Creating folder: %s", folder.FullSlug)

        created, err := fpb.api.CreateStoryWithPublish(ctx, fpb.tgtSpaceID, folder, fpb.publish)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: Failed to create folder %s: %v", folder.FullSlug, err)
                return sb.Story{}, err
        }</span>

        <span class="cov8" title="1">log.Printf("DEBUG: Successfully created folder %s (ID: %d)", created.FullSlug, created.ID)

        return created, nil</span>
}

// ensureFolderPathImpl creates missing folders in a path hierarchy using modular approach
func ensureFolderPathImpl(api folderAPI, report *Report, sourceStories []sb.Story, srcSpaceID, tgtSpaceID int, slug string, publish bool) ([]sb.Story, error) <span class="cov8" title="1">{
        parts := strings.Split(slug, "/")
        if len(parts) &lt;= 1 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">builder := newFolderPathBuilder(api, report, sourceStories, srcSpaceID, tgtSpaceID, publish)
        var created []sb.Story
        var parentID *int

        // Process each folder in the path hierarchy
        for i := 0; i &lt; len(parts)-1; i++ </span><span class="cov8" title="1">{
                path := strings.Join(parts[:i+1], "/")

                ctx, cancel := context.WithTimeout(context.Background(), defaultTimeout)

                // Check if folder already exists
                existing, err := builder.checkExistingFolder(ctx, path)
                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        return created, err
                }</span>

                <span class="cov8" title="1">if existing != nil </span><span class="cov0" title="0">{
                        // Folder exists, use its ID as parent for next level
                        parentID = &amp;existing.ID
                        continue</span>
                }

                // Folder doesn't exist, create it
                <span class="cov8" title="1">ctx, cancel = context.WithTimeout(context.Background(), defaultTimeout)
                folder, err := builder.prepareSourceFolder(ctx, path, parentID)
                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        return created, err
                }</span>

                // Create the folder
                <span class="cov8" title="1">ctx, cancel = context.WithTimeout(context.Background(), defaultTimeout)
                createdFolder, err := builder.createFolder(ctx, folder)
                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        return created, err
                }</span>

                <span class="cov8" title="1">created = append(created, createdFolder)
                parentID = &amp;createdFolder.ID

                // Update report
                if report != nil </span><span class="cov8" title="1">{
                        report.AddSuccess(createdFolder.FullSlug, operationCreate, 0, &amp;createdFolder)
                }</span>
        }

        <span class="cov8" title="1">return created, nil</span>
}

func (m *Model) ensureFolderPath(slug string) ([]sb.Story, error) <span class="cov0" title="0">{
        return ensureFolderPathImpl(m.api, &amp;m.report, m.storiesSource, m.sourceSpace.ID, m.targetSpace.ID, slug, m.shouldPublish())
}</span>

func (m *Model) shouldPublish() bool <span class="cov8" title="1">{
        if m.targetSpace != nil &amp;&amp; m.targetSpace.PlanLevel == 999 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// syncFolder handles folder synchronization with proper parent resolution
func (m *Model) syncFolder(sourceFolder sb.Story) error <span class="cov0" title="0">{
        log.Printf("Syncing folder: %s", sourceFolder.FullSlug)

        // Use the sourceFolder data directly, which should already have content
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
        defer cancel()

        fullFolder := sourceFolder

        // DEBUG: Log content preservation
        log.Printf("DEBUG: syncFolder %s has content: %t, is_folder: %t", sourceFolder.FullSlug, len(sourceFolder.Content) &gt; 0, sourceFolder.IsFolder)
        if len(sourceFolder.Content) &gt; 0 </span><span class="cov0" title="0">{
                contentKeys := sync.GetContentKeys(sourceFolder.Content)
                log.Printf("DEBUG: syncFolder source content keys: %v", contentKeys)

                // Special logging for content_types field
                if sourceFolder.IsFolder </span><span class="cov0" title="0">{
                        if v, ok := sync.GetContentField(sourceFolder.Content, "content_types"); ok </span><span class="cov0" title="0">{
                                log.Printf("DEBUG: syncFolder %s has content_types: %v", sourceFolder.FullSlug, v)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("DEBUG: syncFolder %s missing content_types field", sourceFolder.FullSlug)
                        }</span>
                }
        }
        <span class="cov0" title="0">log.Printf("DEBUG: syncFolder %s ContentType field: '%s'", sourceFolder.FullSlug, sourceFolder.ContentType)

        // If the source folder doesn't have content, try to fetch it from API
        if len(fullFolder.Content) == 0 </span><span class="cov0" title="0">{
                apiFolder, err := m.api.GetStoryWithContent(ctx, m.sourceSpace.ID, sourceFolder.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Preserve any content that came from the API
                <span class="cov0" title="0">if len(apiFolder.Content) &gt; 0 </span><span class="cov0" title="0">{
                        fullFolder.Content = apiFolder.Content
                }</span> else<span class="cov0" title="0"> {
                        // Create minimal content structure for folders
                        fullFolder.Content = json.RawMessage([]byte(`{}`))
                }</span>
        }

        // Don't modify ContentType or Content - preserve exactly as from source

        // Check if folder already exists in target
        <span class="cov0" title="0">existing, err := m.api.GetStoriesBySlug(ctx, m.targetSpace.ID, sourceFolder.FullSlug)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Resolve parent folder ID
        <span class="cov0" title="0">if fullFolder.FolderID != nil </span><span class="cov0" title="0">{
                parentSlug := parentSlug(fullFolder.FullSlug)
                if parentSlug != "" </span><span class="cov0" title="0">{
                        if targetParents, err := m.api.GetStoriesBySlug(ctx, m.targetSpace.ID, parentSlug); err == nil &amp;&amp; len(targetParents) &gt; 0 </span><span class="cov0" title="0">{
                                fullFolder.FolderID = &amp;targetParents[0].ID
                        }</span> else<span class="cov0" title="0"> {
                                fullFolder.FolderID = nil // Set to root if parent not found
                        }</span>
                }
        }

        // Handle translated slugs
        <span class="cov0" title="0">fullFolder = m.processTranslatedSlugs(fullFolder, existing)

        if len(existing) &gt; 0 </span><span class="cov0" title="0">{
                // Update existing folder
                existingFolder := existing[0]
                fullFolder.ID = existingFolder.ID
                updated, err := updateStoryWithPublishRetry(ctx, m.api, m.targetSpace.ID, fullFolder, m.shouldPublish())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Update UUID if different
                <span class="cov0" title="0">if updated.UUID != fullFolder.UUID &amp;&amp; fullFolder.UUID != "" </span><span class="cov0" title="0">{
                        if err := m.api.UpdateStoryUUID(ctx, m.targetSpace.ID, updated.ID, fullFolder.UUID); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to update UUID for folder %s: %v", fullFolder.FullSlug, err)
                        }</span>
                }

                <span class="cov0" title="0">log.Printf("Updated folder: %s", fullFolder.FullSlug)</span>
        } else<span class="cov0" title="0"> {
                // Create new folder
                // Clear ALL fields that shouldn't be set on creation (based on Storyblok CLI)
                fullFolder.ID = 0
                fullFolder.CreatedAt = ""
                fullFolder.UpdatedAt = "" // This was causing 422!

                // Note: Don't reset Position and FolderID here as they are set by parent resolution above

                // Ensure folders have proper content structure
                if fullFolder.IsFolder &amp;&amp; len(fullFolder.Content) == 0 </span><span class="cov0" title="0">{
                        fullFolder.Content = json.RawMessage([]byte(`{}`))
                }</span>

                <span class="cov0" title="0">created, err := createStoryWithPublishRetry(ctx, m.api, m.targetSpace.ID, fullFolder, m.shouldPublish())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Update UUID if different
                <span class="cov0" title="0">if created.UUID != fullFolder.UUID &amp;&amp; fullFolder.UUID != "" </span><span class="cov0" title="0">{
                        if err := m.api.UpdateStoryUUID(ctx, m.targetSpace.ID, created.ID, fullFolder.UUID); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to update UUID for new folder %s: %v", fullFolder.FullSlug, err)
                        }</span>
                }

                <span class="cov0" title="0">log.Printf("Created folder: %s", fullFolder.FullSlug)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// syncFolderDetailed handles folder synchronization and returns detailed results
func (m *Model) syncFolderDetailed(sourceFolder sb.Story) (*syncItemResult, error) <span class="cov0" title="0">{
        syncer := sync.NewStorySyncer(m.api, m.sourceSpace.ID, m.targetSpace.ID)
        return syncer.SyncFolderDetailed(sourceFolder, m.shouldPublish())
}</span>

// executeSync has been moved to sync/api_adapters.go as ExecuteSync

// itemType returns a string describing the item type for logging
func itemType(story sb.Story) string <span class="cov0" title="0">{
        return sync.ItemType(story)
}</span>

// syncStoryContent handles story synchronization with proper UUID management
func (m *Model) syncStoryContent(sourceStory sb.Story) error <span class="cov0" title="0">{
        log.Printf("Syncing story: %s", sourceStory.FullSlug)

        // Get full story content from source
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        fullStory, err := m.api.GetStoryWithContent(ctx, m.sourceSpace.ID, sourceStory.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if story already exists in target
        <span class="cov0" title="0">existing, err := m.api.GetStoriesBySlug(ctx, m.targetSpace.ID, sourceStory.FullSlug)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Resolve parent folder ID if story is in a folder
        <span class="cov0" title="0">if fullStory.FolderID != nil </span><span class="cov0" title="0">{
                parentSlug := parentSlug(fullStory.FullSlug)
                if parentSlug != "" </span><span class="cov0" title="0">{
                        if targetParents, err := m.api.GetStoriesBySlug(ctx, m.targetSpace.ID, parentSlug); err == nil &amp;&amp; len(targetParents) &gt; 0 </span><span class="cov0" title="0">{
                                fullStory.FolderID = &amp;targetParents[0].ID
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("Warning: parent folder %s not found for story %s", parentSlug, fullStory.FullSlug)
                                fullStory.FolderID = nil // Set to root if parent not found
                        }</span>
                }
        }

        // Handle translated slugs
        <span class="cov0" title="0">fullStory = m.processTranslatedSlugs(fullStory, existing)

        if len(existing) &gt; 0 </span><span class="cov0" title="0">{
                // Update existing story
                existingStory := existing[0]
                fullStory.ID = existingStory.ID
                updated, err := updateStoryWithPublishRetry(ctx, m.api, m.targetSpace.ID, fullStory, m.shouldPublish())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Update UUID if different
                <span class="cov0" title="0">if updated.UUID != fullStory.UUID &amp;&amp; fullStory.UUID != "" </span><span class="cov0" title="0">{
                        if err := m.api.UpdateStoryUUID(ctx, m.targetSpace.ID, updated.ID, fullStory.UUID); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to update UUID for story %s: %v", fullStory.FullSlug, err)
                        }</span>
                }

                <span class="cov0" title="0">log.Printf("Updated story: %s", fullStory.FullSlug)</span>
        } else<span class="cov0" title="0"> {
                // Create new story
                // Clear ALL fields that shouldn't be set on creation (based on Storyblok CLI)
                fullStory.ID = 0
                fullStory.CreatedAt = ""
                fullStory.UpdatedAt = "" // This was causing 422!

                // Note: Don't reset Position and FolderID here as they are set by parent resolution above

                // Ensure stories have content (required for Storyblok API)
                if !fullStory.IsFolder &amp;&amp; len(fullStory.Content) == 0 </span><span class="cov0" title="0">{
                        contentBytes, _ := json.Marshal(map[string]interface{}{
                                "component": "page",
                        })
                        fullStory.Content = json.RawMessage(contentBytes)
                }</span>

                <span class="cov0" title="0">created, err := createStoryWithPublishRetry(ctx, m.api, m.targetSpace.ID, fullStory, m.shouldPublish())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Update UUID if different
                <span class="cov0" title="0">if created.UUID != fullStory.UUID &amp;&amp; fullStory.UUID != "" </span><span class="cov0" title="0">{
                        if err := m.api.UpdateStoryUUID(ctx, m.targetSpace.ID, created.ID, fullStory.UUID); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to update UUID for new story %s: %v", fullStory.FullSlug, err)
                        }</span>
                }

                <span class="cov0" title="0">log.Printf("Created story: %s", fullStory.FullSlug)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// syncStoryContentDetailed handles story synchronization and returns detailed results
// Note: Folder structure is now pre-planned in optimizePreflight(), so no need to ensure folder path here
func (m *Model) syncStoryContentDetailed(sourceStory sb.Story) (*syncItemResult, error) <span class="cov0" title="0">{
        syncer := sync.NewStorySyncer(m.api, m.sourceSpace.ID, m.targetSpace.ID)
        return syncer.SyncStoryDetailed(sourceStory, m.shouldPublish())
}</span>

// processTranslatedSlugs handles translated slug processing like the Storyblok CLI
func (m *Model) processTranslatedSlugs(sourceStory sb.Story, existingStories []sb.Story) sb.Story <span class="cov8" title="1">{
        return sync.ProcessTranslatedSlugs(sourceStory, existingStories)
}</span>

func (m *Model) syncStartsWith(slug string) error <span class="cov0" title="0">{
        bulkSyncer := sync.NewBulkSyncer(m.api, m.storiesSource, m.sourceSpace.ID, m.targetSpace.ID)
        return bulkSyncer.SyncStartsWith(slug)
}</span>

// syncStartsWithDetailed syncs all content with prefix and returns results
func (m *Model) syncStartsWithDetailed(slug string) (*syncItemResult, error) <span class="cov0" title="0">{
        bulkSyncer := sync.NewBulkSyncer(m.api, m.storiesSource, m.sourceSpace.ID, m.targetSpace.ID)
        return bulkSyncer.SyncStartsWithDetailed(slug)
}</span>

// Legacy helper functions that now use the extracted bulk operations module
func (m *Model) findTarget(fullSlug string) int <span class="cov0" title="0">{
        return sync.FindTarget(m.storiesTarget, fullSlug)
}</span>

func (m *Model) findSource(fullSlug string) (sb.Story, bool) <span class="cov0" title="0">{
        return sync.FindSource(m.storiesSource, fullSlug)
}</span>

func (m *Model) nextTargetID() int <span class="cov0" title="0">{
        return sync.NextTargetID(m.storiesTarget)
}</span>

// Legacy wrapper for parent slug extraction
func parentSlug(full string) string <span class="cov8" title="1">{
        return sync.ParentSlug(full)
}</span>

// Adapter functions to convert between UI and sync module types

// reportAdapter adapts UI Report to sync ReportInterface
type reportAdapter struct {
        report *Report
}

func (ra *reportAdapter) AddSuccess(slug, operation string, duration int64, story *sb.Story) <span class="cov0" title="0">{
        ra.report.AddSuccess(slug, operation, duration, story)
}</span>

func (ra *reportAdapter) AddWarning(slug, operation, warning string, duration int64, sourceStory, targetStory *sb.Story) <span class="cov0" title="0">{
        ra.report.AddWarning(slug, operation, warning, duration, sourceStory, targetStory)
}</span>

func (ra *reportAdapter) AddError(slug, operation string, duration int64, sourceStory *sb.Story, err error) <span class="cov0" title="0">{
        ra.report.AddError(slug, operation, err.Error(), duration, sourceStory)
}</span>

// convertToSyncPreflightItems converts UI PreflightItem slice to sync PreflightItem slice
func convertToSyncPreflightItems(uiItems []PreflightItem) []sync.PreflightItem <span class="cov8" title="1">{
        syncItems := make([]sync.PreflightItem, len(uiItems))
        for i, uiItem := range uiItems </span><span class="cov8" title="1">{
                syncItems[i] = sync.PreflightItem{
                        Story:      uiItem.Story,
                        Collision:  uiItem.Collision,
                        Skip:       uiItem.Skip,
                        Selected:   uiItem.Selected,
                        State:      string(uiItem.State),
                        StartsWith: uiItem.StartsWith,
                        Run:        convertRunStateToString(uiItem.Run),
                }
        }</span>
        <span class="cov8" title="1">return syncItems</span>
}

// convertFromSyncPreflightItems converts sync PreflightItem slice to UI PreflightItem slice
func convertFromSyncPreflightItems(syncItems []sync.PreflightItem) []PreflightItem <span class="cov8" title="1">{
        uiItems := make([]PreflightItem, len(syncItems))
        for i, syncItem := range syncItems </span><span class="cov8" title="1">{
                uiItems[i] = PreflightItem{
                        Story:      syncItem.Story,
                        Collision:  syncItem.Collision,
                        Skip:       syncItem.Skip,
                        Selected:   syncItem.Selected,
                        State:      SyncState(syncItem.State),
                        StartsWith: syncItem.StartsWith,
                        Run:        convertStringToRunState(syncItem.Run),
                }
        }</span>
        <span class="cov8" title="1">return uiItems</span>
}

// Helper functions for type conversion
func convertRunStateToString(runState RunState) string <span class="cov8" title="1">{
        switch runState </span>{
        case RunPending:<span class="cov8" title="1">
                return "pending"</span>
        case RunRunning:<span class="cov0" title="0">
                return "running"</span>
        case RunDone:<span class="cov0" title="0">
                return "success"</span>
        case RunCancelled:<span class="cov0" title="0">
                return "failed"</span>
        default:<span class="cov0" title="0">
                return "pending"</span>
        }
}

func convertStringToRunState(runString string) RunState <span class="cov8" title="1">{
        switch runString </span>{
        case "pending":<span class="cov8" title="1">
                return RunPending</span>
        case "running":<span class="cov0" title="0">
                return RunRunning</span>
        case "success":<span class="cov0" title="0">
                return RunDone</span>
        case "failed":<span class="cov0" title="0">
                return RunCancelled</span>
        default:<span class="cov0" title="0">
                return RunPending</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package sync

import (
        "context"
        "log"
        "strings"

        "storyblok-sync/internal/sb"
)

// APIAdapter provides API operations with retry and error handling logic
type APIAdapter struct {
        api SyncAPI
}

// NewAPIAdapter creates a new API adapter
func NewAPIAdapter(api SyncAPI) *APIAdapter <span class="cov8" title="1">{
        return &amp;APIAdapter{
                api: api,
        }
}</span>

// IsRateLimited checks if an error indicates rate limiting
func IsRateLimited(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">errStr := err.Error()
        return strings.Contains(errStr, "429") || strings.Contains(errStr, "rate limit")</span>
}

// IsDevModePublishLimit checks if error is due to publish limit in dev mode
func IsDevModePublishLimit(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())
        return strings.Contains(errStr, "plan limit") ||
                strings.Contains(errStr, "publish limit") ||
                strings.Contains(errStr, "exceeded") ||
                strings.Contains(errStr, "development mode") ||
                strings.Contains(errStr, "publishing is limited")</span>
}

// UpdateStoryWithPublishRetry attempts to update a story with publish retry fallback
func (aa *APIAdapter) UpdateStoryWithPublishRetry(ctx context.Context, spaceID int, story sb.Story, publish bool) (sb.Story, error) <span class="cov8" title="1">{
        updated, err := aa.api.UpdateStory(ctx, spaceID, story, publish)
        if err != nil &amp;&amp; IsDevModePublishLimit(err) &amp;&amp; publish </span><span class="cov8" title="1">{
                // Retry without publishing if we hit publish limit
                log.Printf("Publish limit reached, retrying without publish for %s", story.FullSlug)
                return aa.api.UpdateStory(ctx, spaceID, story, false)
        }</span>
        <span class="cov8" title="1">return updated, err</span>
}

// CreateStoryWithPublishRetry attempts to create a story with publish retry fallback
func (aa *APIAdapter) CreateStoryWithPublishRetry(ctx context.Context, spaceID int, story sb.Story, publish bool) (sb.Story, error) <span class="cov8" title="1">{
        created, err := aa.api.CreateStoryWithPublish(ctx, spaceID, story, publish)
        if err != nil &amp;&amp; IsDevModePublishLimit(err) &amp;&amp; publish </span><span class="cov8" title="1">{
                // Retry without publishing if we hit publish limit
                log.Printf("Publish limit reached, retrying without publish for %s", story.FullSlug)
                return aa.api.CreateStoryWithPublish(ctx, spaceID, story, false)
        }</span>
        <span class="cov8" title="1">return created, err</span>
}

// ExecuteSync performs common create/update logic based on whether target exists
func (aa *APIAdapter) ExecuteSync(ctx context.Context, spaceID int, story sb.Story, existingTarget *sb.Story, publish bool) (sb.Story, string, error) <span class="cov8" title="1">{
        var operation string
        var result sb.Story
        var err error

        if existingTarget != nil </span><span class="cov8" title="1">{
                // Update existing story
                operation = OperationUpdate
                updateStory := PrepareStoryForUpdate(story, *existingTarget)
                result, err = aa.UpdateStoryWithPublishRetry(ctx, spaceID, updateStory, publish)
        }</span> else<span class="cov8" title="1"> {
                // Create new story
                operation = OperationCreate
                createStory := PrepareStoryForCreation(story)
                result, err = aa.CreateStoryWithPublishRetry(ctx, spaceID, createStory, publish)
        }</span>

        <span class="cov8" title="1">return result, operation, err</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package sync

import (
        "fmt"
        "log"
        "sort"
        "strings"

        "storyblok-sync/internal/sb"
)

// BulkSyncer handles bulk synchronization operations
type BulkSyncer struct {
        api           SyncAPI
        sourceStories []sb.Story
        sourceSpaceID int
        targetSpaceID int
}

// NewBulkSyncer creates a new bulk synchronizer
func NewBulkSyncer(api SyncAPI, sourceStories []sb.Story, sourceSpaceID, targetSpaceID int) *BulkSyncer <span class="cov0" title="0">{
        return &amp;BulkSyncer{
                api:           api,
                sourceStories: sourceStories,
                sourceSpaceID: sourceSpaceID,
                targetSpaceID: targetSpaceID,
        }
}</span>

// SyncStartsWith syncs all content with the given slug prefix
func (bs *BulkSyncer) SyncStartsWith(slug string) error <span class="cov0" title="0">{
        log.Printf("Syncing all content starting with: %s", slug)

        // Get all stories/folders that match the prefix
        toSync := bs.getStoriesWithPrefix(slug)

        // Sort by type and depth (folders first, then stories)
        bs.sortByTypeAndDepth(toSync)

        // Create story syncer for individual operations
        syncer := NewStorySyncer(bs.api, bs.sourceSpaceID, bs.targetSpaceID)

        // Sync each item in the correct order
        for _, st := range toSync </span><span class="cov0" title="0">{
                var err error
                if st.IsFolder </span><span class="cov0" title="0">{
                        _, err = syncer.SyncFolderDetailed(st, true) // Assume publish = true for bulk ops
                }</span> else<span class="cov0" title="0"> {
                        _, err = syncer.SyncStoryDetailed(st, true)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">log.Printf("Completed syncing %d items starting with %s", len(toSync), slug)
        return nil</span>
}

// SyncStartsWithDetailed syncs all content with prefix and returns detailed results
func (bs *BulkSyncer) SyncStartsWithDetailed(slug string) (*SyncItemResult, error) <span class="cov0" title="0">{
        log.Printf("Syncing all content starting with: %s", slug)

        // Get all stories/folders that match the prefix
        toSync := bs.getStoriesWithPrefix(slug)

        // Sort by type and depth (folders first, then stories)
        bs.sortByTypeAndDepth(toSync)

        // Create story syncer for individual operations
        syncer := NewStorySyncer(bs.api, bs.sourceSpaceID, bs.targetSpaceID)

        var warnings []string
        totalCreated := 0
        totalUpdated := 0

        // Sync each item in the correct order
        for _, st := range toSync </span><span class="cov0" title="0">{
                var result *SyncItemResult
                var err error

                if st.IsFolder </span><span class="cov0" title="0">{
                        result, err = syncer.SyncFolderDetailed(st, true)
                }</span> else<span class="cov0" title="0"> {
                        result, err = syncer.SyncStoryDetailed(st, true)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if result != nil </span><span class="cov0" title="0">{
                        if result.Operation == OperationCreate </span><span class="cov0" title="0">{
                                totalCreated++
                        }</span> else<span class="cov0" title="0"> if result.Operation == OperationUpdate </span><span class="cov0" title="0">{
                                totalUpdated++
                        }</span>

                        <span class="cov0" title="0">if result.Warning != "" </span><span class="cov0" title="0">{
                                warnings = append(warnings, fmt.Sprintf("%s: %s", st.FullSlug, result.Warning))
                        }</span>
                }
        }

        <span class="cov0" title="0">operation := fmt.Sprintf("bulk (%d created, %d updated)", totalCreated, totalUpdated)
        warning := ""
        if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                warning = strings.Join(warnings, "; ")
        }</span>

        <span class="cov0" title="0">log.Printf("Completed syncing %d items starting with %s", len(toSync), slug)
        return &amp;SyncItemResult{
                Operation: operation,
                Warning:   warning,
        }, nil</span>
}

// getStoriesWithPrefix returns all stories that match the slug prefix
func (bs *BulkSyncer) getStoriesWithPrefix(slug string) []sb.Story <span class="cov0" title="0">{
        var toSync []sb.Story
        for _, st := range bs.sourceStories </span><span class="cov0" title="0">{
                if st.FullSlug == slug || strings.HasPrefix(st.FullSlug, slug+"/") </span><span class="cov0" title="0">{
                        toSync = append(toSync, st)
                }</span>
        }
        <span class="cov0" title="0">return toSync</span>
}

// sortByTypeAndDepth sorts stories by type (folders first) and depth (shallow first)
func (bs *BulkSyncer) sortByTypeAndDepth(stories []sb.Story) <span class="cov0" title="0">{
        sort.Slice(stories, func(i, j int) bool </span><span class="cov0" title="0">{
                storyI, storyJ := stories[i], stories[j]

                // Folders always come before stories
                if storyI.IsFolder &amp;&amp; !storyJ.IsFolder </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if !storyI.IsFolder &amp;&amp; storyJ.IsFolder </span><span class="cov0" title="0">{
                        return false
                }</span>

                // Both are folders or both are stories - sort by depth (shallow first)
                <span class="cov0" title="0">depthI := strings.Count(storyI.FullSlug, "/")
                depthJ := strings.Count(storyJ.FullSlug, "/")

                if depthI != depthJ </span><span class="cov0" title="0">{
                        return depthI &lt; depthJ
                }</span>

                <span class="cov0" title="0">return storyI.FullSlug &lt; storyJ.FullSlug</span>
        })
}

// FindTarget searches for a story in the target space by full slug
func FindTarget(targetStories []sb.Story, fullSlug string) int <span class="cov0" title="0">{
        for i, st := range targetStories </span><span class="cov0" title="0">{
                if st.FullSlug == fullSlug </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// FindSource searches for a story in the source space by full slug
func FindSource(sourceStories []sb.Story, fullSlug string) (sb.Story, bool) <span class="cov0" title="0">{
        for _, st := range sourceStories </span><span class="cov0" title="0">{
                if st.FullSlug == fullSlug </span><span class="cov0" title="0">{
                        return st, true
                }</span>
        }
        <span class="cov0" title="0">return sb.Story{}, false</span>
}

// NextTargetID returns the next available ID in the target space
func NextTargetID(targetStories []sb.Story) int <span class="cov0" title="0">{
        max := 0
        for _, st := range targetStories </span><span class="cov0" title="0">{
                if st.ID &gt; max </span><span class="cov0" title="0">{
                        max = st.ID
                }</span>
        }
        <span class="cov0" title="0">return max + 1</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package sync

import (
        "context"

        "encoding/json"
        "storyblok-sync/internal/sb"
)

// folderAPI interface defines the methods needed for content management
type folderAPI interface {
        GetStoryWithContent(ctx context.Context, spaceID, storyID int) (sb.Story, error)
}

// ContentManager handles story content fetching and caching
type ContentManager struct {
        api      folderAPI
        spaceID  int
        cache    map[int]sb.Story
        maxSize  int
        hitCount int
}

// NewContentManager creates a new content manager with cache size limit
func NewContentManager(api folderAPI, spaceID int) *ContentManager <span class="cov8" title="1">{
        return &amp;ContentManager{
                api:     api,
                spaceID: spaceID,
                cache:   make(map[int]sb.Story),
                maxSize: 500, // Limit cache to 500 entries
        }
}</span>

// EnsureContent fetches story content if not present, with caching
func (cm *ContentManager) EnsureContent(ctx context.Context, story sb.Story) (sb.Story, error) <span class="cov8" title="1">{
        // Return if content already exists
        if len(story.Content) &gt; 0 </span><span class="cov8" title="1">{
                return story, nil
        }</span>

        // Check cache first
        <span class="cov8" title="1">if cached, exists := cm.cache[story.ID]; exists &amp;&amp; len(cached.Content) &gt; 0 </span><span class="cov8" title="1">{
                cm.hitCount++
                story.Content = cached.Content
                return story, nil
        }</span>

        // Fetch from API
        <span class="cov8" title="1">fullStory, err := cm.api.GetStoryWithContent(ctx, cm.spaceID, story.ID)
        if err != nil </span><span class="cov8" title="1">{
                return story, err
        }</span>

        // Use fetched content or default
        <span class="cov8" title="1">if len(fullStory.Content) &gt; 0 </span><span class="cov8" title="1">{
                story.Content = fullStory.Content
        }</span> else<span class="cov0" title="0"> {
                story.Content = json.RawMessage([]byte(`{}`))
        }</span>

        // Cache the result with size limit
        <span class="cov8" title="1">cm.addToCache(story)
        return story, nil</span>
}

// addToCache adds a story to the cache with LRU eviction when size limit is reached
func (cm *ContentManager) addToCache(story sb.Story) <span class="cov8" title="1">{
        // If cache is at capacity, remove oldest entries to make room
        if len(cm.cache) &gt;= cm.maxSize </span><span class="cov8" title="1">{
                // Simple eviction: remove entries until we're under the limit
                removeCount := len(cm.cache) - cm.maxSize + 1
                count := 0
                for id := range cm.cache </span><span class="cov8" title="1">{
                        if count &gt;= removeCount </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">delete(cm.cache, id)
                        count++</span>
                }
        }
        <span class="cov8" title="1">cm.cache[story.ID] = story</span>
}

// CacheStats returns cache statistics
func (cm *ContentManager) CacheStats() (size, maxSize int) <span class="cov0" title="0">{
        return len(cm.cache), cm.maxSize
}</span>

// ClearCache clears the entire cache
func (cm *ContentManager) ClearCache() <span class="cov0" title="0">{
        cm.cache = make(map[int]sb.Story)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package sync

import (
        "context"
        "fmt"
        "log"
        "strings"
        "time"

        "storyblok-sync/internal/sb"
)

// Timeout constants
const (
        DefaultTimeout = 15 * time.Second
)

// FolderAPI interface defines the methods needed for folder operations
type FolderAPI interface {
        GetStoriesBySlug(ctx context.Context, spaceID int, slug string) ([]sb.Story, error)
        GetStoryWithContent(ctx context.Context, spaceID, storyID int) (sb.Story, error)
        CreateStoryWithPublish(ctx context.Context, spaceID int, st sb.Story, publish bool) (sb.Story, error)
}

// Report interface for folder creation reporting
type Report interface {
        AddSuccess(slug, operation string, duration int64, story *sb.Story)
}

// FolderPathBuilder handles the creation of folder hierarchies
type FolderPathBuilder struct {
        api           FolderAPI
        report        Report
        sourceStories map[string]sb.Story
        contentMgr    *ContentManager
        srcSpaceID    int
        tgtSpaceID    int
        publish       bool
}

// NewFolderPathBuilder creates a new folder path builder
func NewFolderPathBuilder(api FolderAPI, report Report, sourceStories []sb.Story, srcSpaceID, tgtSpaceID int, publish bool) *FolderPathBuilder <span class="cov0" title="0">{
        // Build source stories map for quick lookup
        sourceMap := make(map[string]sb.Story)
        for _, story := range sourceStories </span><span class="cov0" title="0">{
                sourceMap[story.FullSlug] = story
        }</span>

        <span class="cov0" title="0">return &amp;FolderPathBuilder{
                api:           api,
                report:        report,
                sourceStories: sourceMap,
                contentMgr:    NewContentManager(api, srcSpaceID),
                srcSpaceID:    srcSpaceID,
                tgtSpaceID:    tgtSpaceID,
                publish:       publish,
        }</span>
}

// CheckExistingFolder checks if a folder exists in the target space
func (fpb *FolderPathBuilder) CheckExistingFolder(ctx context.Context, path string) (*sb.Story, error) <span class="cov0" title="0">{
        existing, err := fpb.api.GetStoriesBySlug(ctx, fpb.tgtSpaceID, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(existing) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">folder := existing[0]
        log.Printf("DEBUG: Found existing folder: %s (ID: %d)", path, folder.ID)
        return &amp;folder, nil</span>
}

// PrepareSourceFolder prepares a source folder for creation in target space
func (fpb *FolderPathBuilder) PrepareSourceFolder(ctx context.Context, path string, parentID *int) (sb.Story, error) <span class="cov0" title="0">{
        source, exists := fpb.sourceStories[path]
        if !exists </span><span class="cov0" title="0">{
                return sb.Story{}, fmt.Errorf("source folder not found: %s", path)
        }</span>

        // Ensure content is loaded
        <span class="cov0" title="0">folder, err := fpb.contentMgr.EnsureContent(ctx, source)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: Failed to fetch content for folder %s: %v", path, err)
                return sb.Story{}, err
        }</span>

        // Prepare for creation
        <span class="cov0" title="0">folder = PrepareStoryForCreation(folder)
        folder.FolderID = parentID

        log.Printf("DEBUG: Prepared source folder %s with content: %t", path, len(folder.Content) &gt; 0)
        return folder, nil</span>
}

// CreateFolder creates a single folder in the target space
func (fpb *FolderPathBuilder) CreateFolder(ctx context.Context, folder sb.Story) (sb.Story, error) <span class="cov0" title="0">{
        log.Printf("DEBUG: Creating folder: %s", folder.FullSlug)

        created, err := fpb.api.CreateStoryWithPublish(ctx, fpb.tgtSpaceID, folder, fpb.publish)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("DEBUG: Failed to create folder %s: %v", folder.FullSlug, err)
                return sb.Story{}, err
        }</span>

        <span class="cov0" title="0">log.Printf("DEBUG: Successfully created folder %s (ID: %d)", created.FullSlug, created.ID)
        return created, nil</span>
}

// EnsureFolderPath creates missing folders in a path hierarchy
func (fpb *FolderPathBuilder) EnsureFolderPath(slug string) ([]sb.Story, error) <span class="cov0" title="0">{
        parts := strings.Split(slug, "/")
        if len(parts) &lt;= 1 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var created []sb.Story
        var parentID *int

        // Process each folder in the path hierarchy
        for i := 0; i &lt; len(parts)-1; i++ </span><span class="cov0" title="0">{
                path := strings.Join(parts[:i+1], "/")

                ctx, cancel := context.WithTimeout(context.Background(), DefaultTimeout)

                // Check if folder already exists
                existing, err := fpb.CheckExistingFolder(ctx, path)
                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        return created, err
                }</span>

                <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                        // Folder exists, use its ID as parent for next level
                        parentID = &amp;existing.ID
                        continue</span>
                }

                // Folder doesn't exist, create it
                <span class="cov0" title="0">ctx, cancel = context.WithTimeout(context.Background(), DefaultTimeout)
                folder, err := fpb.PrepareSourceFolder(ctx, path, parentID)
                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        return created, err
                }</span>

                // Create the folder
                <span class="cov0" title="0">ctx, cancel = context.WithTimeout(context.Background(), DefaultTimeout)
                createdFolder, err := fpb.CreateFolder(ctx, folder)
                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        return created, err
                }</span>

                <span class="cov0" title="0">created = append(created, createdFolder)
                parentID = &amp;createdFolder.ID

                // Update report
                if fpb.report != nil </span><span class="cov0" title="0">{
                        fpb.report.AddSuccess(createdFolder.FullSlug, OperationCreate, 0, &amp;createdFolder)
                }</span>
        }

        <span class="cov0" title="0">return created, nil</span>
}

// EnsureFolderPathStatic is a static utility function for ensuring folder paths
func EnsureFolderPathStatic(api FolderAPI, report Report, sourceStories []sb.Story, srcSpaceID, tgtSpaceID int, slug string, publish bool) ([]sb.Story, error) <span class="cov0" title="0">{
        builder := NewFolderPathBuilder(api, report, sourceStories, srcSpaceID, tgtSpaceID, publish)
        return builder.EnsureFolderPath(slug)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package sync

import (
        "context"
        "log"
        "time"

        tea "github.com/charmbracelet/bubbletea"

        "storyblok-sync/internal/sb"
)

// SyncOperations handles the core sync operations
type SyncOperations struct {
        api         FolderAPI
        contentMgr  *ContentManager
        folderMgr   *FolderPathBuilder
        sourceSpace *sb.Space
        targetSpace *sb.Space
}

// NewSyncOperations creates a new sync operations manager
func NewSyncOperations(api FolderAPI, sourceSpace, targetSpace *sb.Space) *SyncOperations <span class="cov0" title="0">{
        return &amp;SyncOperations{
                api:         api,
                contentMgr:  NewContentManager(api, sourceSpace.ID),
                sourceSpace: sourceSpace,
                targetSpace: targetSpace,
        }
}</span>

// RunSyncItem executes sync for a single item with retry logic
func (so *SyncOperations) RunSyncItem(ctx context.Context, idx int, item interface{}) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Check if context is already cancelled before starting
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return SyncResultMsg{Index: idx, Cancelled: true}</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">log.Printf("Starting sync for item %d", idx)
                startTime := time.Now()

                // Implement sync logic here based on item type
                // This is a placeholder for the actual sync implementation

                duration := time.Since(startTime).Milliseconds()

                // Return success result
                return SyncResultMsg{
                        Index:    idx,
                        Duration: duration,
                }</span>
        }
}

// SyncWithRetry executes an operation with retry logic for rate limiting and transient errors
func (so *SyncOperations) SyncWithRetry(operation func() error) error <span class="cov0" title="0">{
        var lastErr error
        for attempt := 0; attempt &lt; 3; attempt++ </span><span class="cov0" title="0">{
                err := operation()
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">lastErr = err
                log.Printf("Sync attempt %d failed: %v", attempt+1, err)

                // Log additional context for retries
                if attempt &lt; 2 </span><span class="cov0" title="0">{
                        retryDelay := so.calculateRetryDelay(err, attempt)
                        log.Printf("  Will retry in %v (attempt %d/3)", retryDelay, attempt+2)
                        time.Sleep(retryDelay)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("  Max retries (3) exceeded, giving up")
                }</span>

                // Check if it's a rate limiting error
                <span class="cov0" title="0">if IsRateLimited(err) </span><span class="cov0" title="0">{
                        sleepDuration := time.Second * time.Duration(attempt+1)
                        log.Printf("Rate limited, sleeping for %v", sleepDuration)
                        time.Sleep(sleepDuration)
                        continue</span>
                }

                // For other errors, use shorter delay
                <span class="cov0" title="0">if attempt &lt; 2 </span><span class="cov0" title="0">{
                        time.Sleep(500 * time.Millisecond)
                }</span>
        }
        <span class="cov0" title="0">return lastErr</span>
}

// calculateRetryDelay calculates the delay before retrying based on error type
func (so *SyncOperations) calculateRetryDelay(err error, attempt int) time.Duration <span class="cov0" title="0">{
        if IsRateLimited(err) </span><span class="cov0" title="0">{
                return time.Second * time.Duration(attempt+1)
        }</span>
        <span class="cov0" title="0">return time.Millisecond * 500</span>
}

// ShouldPublish determines if stories should be published based on space plan
func (so *SyncOperations) ShouldPublish() bool <span class="cov0" title="0">{
        if so.targetSpace != nil &amp;&amp; so.targetSpace.PlanLevel == 999 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Note: IsRateLimited is now in api_adapters.go
</pre>
		
		<pre class="file" id="file26" style="display: none">package sync

import (
        "context"
        "log"
        "time"

        tea "github.com/charmbracelet/bubbletea"

        "storyblok-sync/internal/sb"
)

// SyncOrchestrator manages the execution of sync operations with Bubble Tea integration
type SyncOrchestrator struct {
        api         SyncAPI
        contentMgr  *ContentManager
        report      ReportInterface
        sourceSpace *sb.Space
        targetSpace *sb.Space
}

// SyncAPI defines the interface for sync API operations
type SyncAPI interface {
        GetStoriesBySlug(ctx context.Context, spaceID int, slug string) ([]sb.Story, error)
        GetStoryWithContent(ctx context.Context, spaceID, storyID int) (sb.Story, error)
        CreateStoryWithPublish(ctx context.Context, spaceID int, st sb.Story, publish bool) (sb.Story, error)
        UpdateStory(ctx context.Context, spaceID int, st sb.Story, publish bool) (sb.Story, error)
        UpdateStoryUUID(ctx context.Context, spaceID, storyID int, uuid string) error
}

// ReportInterface defines the interface for reporting sync progress
type ReportInterface interface {
        AddSuccess(slug, operation string, duration int64, story *sb.Story)
        AddWarning(slug, operation, warning string, duration int64, sourceStory, targetStory *sb.Story)
        AddError(slug, operation string, duration int64, sourceStory *sb.Story, err error)
}

// SyncItem represents an item to be synchronized
type SyncItem interface {
        GetStory() sb.Story
        IsStartsWith() bool
        IsFolder() bool
}

// NewSyncOrchestrator creates a new sync orchestrator
func NewSyncOrchestrator(api SyncAPI, report ReportInterface, sourceSpace, targetSpace *sb.Space) *SyncOrchestrator <span class="cov8" title="1">{
        return &amp;SyncOrchestrator{
                api:         api,
                contentMgr:  NewContentManager(api, sourceSpace.ID),
                report:      report,
                sourceSpace: sourceSpace,
                targetSpace: targetSpace,
        }
}</span>

// RunSyncItem executes sync for a single item and returns a Bubble Tea command
func (so *SyncOrchestrator) RunSyncItem(ctx context.Context, idx int, item SyncItem) tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov8" title="1">{
                // Check if context is already cancelled before starting
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return SyncResultMsg{Index: idx, Cancelled: true}</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">story := item.GetStory()
                log.Printf("Starting sync for item %d: %s (folder: %t)", idx, story.FullSlug, story.IsFolder)

                startTime := time.Now()
                var err error
                var result *SyncItemResult

                // Choose sync operation based on item type
                switch </span>{
                case item.IsStartsWith():<span class="cov0" title="0">
                        err = so.SyncWithRetry(func() error </span><span class="cov0" title="0">{
                                var syncErr error
                                result, syncErr = so.SyncStartsWithDetailed(story.FullSlug)
                                return syncErr
                        }</span>)
                case item.IsFolder():<span class="cov0" title="0">
                        err = so.SyncWithRetry(func() error </span><span class="cov0" title="0">{
                                var syncErr error
                                result, syncErr = so.SyncFolderDetailed(story)
                                return syncErr
                        }</span>)
                default:<span class="cov0" title="0">
                        err = so.SyncWithRetry(func() error </span><span class="cov0" title="0">{
                                var syncErr error
                                result, syncErr = so.SyncStoryDetailed(story)
                                return syncErr
                        }</span>)
                }

                <span class="cov0" title="0">duration := time.Since(startTime).Milliseconds()

                // Log results
                if err != nil </span><span class="cov0" title="0">{
                        LogError("sync", story.FullSlug, err, &amp;story)
                }</span> else<span class="cov0" title="0"> if result != nil </span><span class="cov0" title="0">{
                        if result.Warning != "" </span><span class="cov0" title="0">{
                                LogWarning(result.Operation, story.FullSlug, result.Warning, &amp;story)
                        }</span> else<span class="cov0" title="0"> {
                                LogSuccess(result.Operation, story.FullSlug, duration, result.TargetStory)
                        }</span>
                        <span class="cov0" title="0">time.Sleep(50 * time.Millisecond)</span> // Brief pause between operations
                } else<span class="cov0" title="0"> {
                        log.Printf("Sync completed for %s (no detailed result)", story.FullSlug)
                        time.Sleep(50 * time.Millisecond)
                }</span>

                <span class="cov0" title="0">return SyncResultMsg{Index: idx, Err: err, Result: result, Duration: duration}</span>
        }
}

// SyncWithRetry executes an operation with retry logic for rate limiting and transient errors
func (so *SyncOrchestrator) SyncWithRetry(operation func() error) error <span class="cov8" title="1">{
        var lastErr error
        for attempt := 0; attempt &lt; 3; attempt++ </span><span class="cov8" title="1">{
                err := operation()
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">lastErr = err
                log.Printf("Sync attempt %d failed: %v", attempt+1, err)

                // Log additional context for retries
                if attempt &lt; 2 </span><span class="cov8" title="1">{
                        retryDelay := so.calculateRetryDelay(err, attempt)
                        log.Printf("  Will retry in %v (attempt %d/3)", retryDelay, attempt+2)
                        time.Sleep(retryDelay)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("  Max retries (3) exceeded, giving up")
                }</span>

                // Check if it's a rate limiting error
                <span class="cov8" title="1">if IsRateLimited(err) </span><span class="cov8" title="1">{
                        sleepDuration := time.Second * time.Duration(attempt+1)
                        log.Printf("Rate limited, sleeping for %v", sleepDuration)
                        time.Sleep(sleepDuration)
                        continue</span>
                }

                // For other errors, use shorter delay
                <span class="cov8" title="1">if attempt &lt; 2 </span><span class="cov8" title="1">{
                        time.Sleep(500 * time.Millisecond)
                }</span>
        }
        <span class="cov8" title="1">return lastErr</span>
}

// calculateRetryDelay calculates the delay before retrying based on error type
func (so *SyncOrchestrator) calculateRetryDelay(err error, attempt int) time.Duration <span class="cov8" title="1">{
        if IsRateLimited(err) </span><span class="cov8" title="1">{
                return time.Second * time.Duration(attempt+1)
        }</span>
        <span class="cov8" title="1">return time.Millisecond * 500</span>
}

// ShouldPublish determines if stories should be published based on space plan
func (so *SyncOrchestrator) ShouldPublish() bool <span class="cov8" title="1">{
        if so.targetSpace != nil &amp;&amp; so.targetSpace.PlanLevel == 999 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// SyncStartsWithDetailed synchronizes all stories starting with a prefix
func (so *SyncOrchestrator) SyncStartsWithDetailed(prefix string) (*SyncItemResult, error) <span class="cov0" title="0">{
        // TODO: Implement bulk starts-with synchronization
        // This will need to find all stories with the prefix and sync them
        return &amp;SyncItemResult{
                Operation:   OperationSkip,
                TargetStory: nil,
                Warning:     "starts-with sync not yet implemented",
        }, nil
}</span>

// SyncFolderDetailed synchronizes a folder using StorySyncer
func (so *SyncOrchestrator) SyncFolderDetailed(story sb.Story) (*SyncItemResult, error) <span class="cov0" title="0">{
        syncer := NewStorySyncer(so.api, so.sourceSpace.ID, so.targetSpace.ID)
        return syncer.SyncFolderDetailed(story, so.ShouldPublish())
}</span>

// SyncStoryDetailed synchronizes a story using StorySyncer
func (so *SyncOrchestrator) SyncStoryDetailed(story sb.Story) (*SyncItemResult, error) <span class="cov0" title="0">{
        syncer := NewStorySyncer(so.api, so.sourceSpace.ID, so.targetSpace.ID)
        return syncer.SyncStoryDetailed(story, so.ShouldPublish())
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package sync

import (
        "log"
        "sort"
        "strings"

        "storyblok-sync/internal/sb"
)

// PreflightItem represents an item in the preflight plan (using UI types for compatibility)
type PreflightItem struct {
        Story      sb.Story
        Collision  bool
        Skip       bool
        Selected   bool
        State      string // StateCreate, StateUpdate, etc.
        StartsWith bool
        Run        string // RunPending, RunRunning, etc.
}

// State constants for preflight items
const (
        StateCreate = "create"
        StateUpdate = "update"
        StateSkip   = "skip"
)

// Run state constants
const (
        RunPending = "pending"
        RunRunning = "running"
        RunSuccess = "success"
        RunFailed  = "failed"
)

// PreflightPlanner handles preflight planning and optimization
type PreflightPlanner struct {
        sourceStories []sb.Story
        targetStories []sb.Story
}

// NewPreflightPlanner creates a new preflight planner
func NewPreflightPlanner(sourceStories, targetStories []sb.Story) *PreflightPlanner <span class="cov0" title="0">{
        return &amp;PreflightPlanner{
                sourceStories: sourceStories,
                targetStories: targetStories,
        }
}</span>

// OptimizePreflight deduplicates and sorts preflight items for optimal sync order
func (pp *PreflightPlanner) OptimizePreflight(items []PreflightItem) []PreflightItem <span class="cov0" title="0">{
        log.Printf("Optimizing preflight with %d items", len(items))

        // Deduplicate by FullSlug
        selected := make(map[string]*PreflightItem)
        for i := range items </span><span class="cov0" title="0">{
                it := &amp;items[i]
                if it.Skip </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if _, ok := selected[it.Story.FullSlug]; ok </span><span class="cov0" title="0">{
                        it.Skip = true
                        continue</span>
                }
                <span class="cov0" title="0">selected[it.Story.FullSlug] = it</span>
        }

        // Create initial optimized list
        <span class="cov0" title="0">optimized := make([]PreflightItem, 0, len(items))
        for _, it := range items </span><span class="cov0" title="0">{
                if it.Skip </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">it.Run = RunPending
                optimized = append(optimized, it)</span>
        }

        // Find and add missing folder paths
        <span class="cov0" title="0">missingFolders := pp.FindMissingFolderPaths(optimized)
        log.Printf("Found %d missing folders that need to be created", len(missingFolders))

        // Build a map of already included slugs to avoid duplicates
        existingSlugs := make(map[string]bool)
        for _, item := range optimized </span><span class="cov0" title="0">{
                existingSlugs[item.Story.FullSlug] = true
        }</span>

        // Add missing folders to the plan
        <span class="cov0" title="0">for _, folder := range missingFolders </span><span class="cov0" title="0">{
                // Skip if folder is already included in the optimization list
                if existingSlugs[folder.FullSlug] </span><span class="cov0" title="0">{
                        log.Printf("DEBUG: Folder %s already in optimization list, skipping auto-add", folder.FullSlug)
                        continue</span>
                }

                // Create preflight item for missing folder
                <span class="cov0" title="0">folderItem := PreflightItem{
                        Story:     folder,
                        Collision: false, // Missing folders don't have collisions
                        Skip:      false,
                        Selected:  true, // Auto-selected for sync
                        State:     StateCreate,
                        Run:       RunPending,
                }
                optimized = append(optimized, folderItem)
                existingSlugs[folder.FullSlug] = true
                log.Printf("DEBUG: Auto-added missing folder to preflight: %s", folder.FullSlug)</span>
        }

        // Sort by sync priority: folders first (by depth), then stories
        <span class="cov0" title="0">sort.Slice(optimized, func(i, j int) bool </span><span class="cov0" title="0">{
                itemI, itemJ := optimized[i], optimized[j]

                // Folders always come before stories
                if itemI.Story.IsFolder &amp;&amp; !itemJ.Story.IsFolder </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if !itemI.Story.IsFolder &amp;&amp; itemJ.Story.IsFolder </span><span class="cov0" title="0">{
                        return false
                }</span>

                // Both are folders or both are stories - sort by depth (shallow first)
                <span class="cov0" title="0">depthI := strings.Count(itemI.Story.FullSlug, "/")
                depthJ := strings.Count(itemJ.Story.FullSlug, "/")

                if depthI != depthJ </span><span class="cov0" title="0">{
                        return depthI &lt; depthJ
                }</span>

                // Same depth - sort alphabetically for consistent order
                <span class="cov0" title="0">return itemI.Story.FullSlug &lt; itemJ.Story.FullSlug</span>
        })

        // Update the list
        <span class="cov0" title="0">log.Printf("Optimized to %d items (%d missing folders auto-added), sync order: folders first, then stories",
                len(optimized), len(missingFolders))

        return optimized</span>
}

// FindMissingFolderPaths analyzes preflight items and finds missing parent folders
func (pp *PreflightPlanner) FindMissingFolderPaths(items []PreflightItem) []sb.Story <span class="cov0" title="0">{
        // Build target folder map for quick lookup
        targetFolderMap := pp.BuildTargetFolderMap()

        missingPaths := make(map[string]bool)

        // For each item, check if all parent folders exist
        for _, item := range items </span><span class="cov0" title="0">{
                // Get all parent paths for this story
                folderPaths := GetFolderPaths(item.Story.FullSlug)

                for _, path := range folderPaths </span><span class="cov0" title="0">{
                        // Check if this folder path exists in target
                        if _, exists := targetFolderMap[path]; !exists </span><span class="cov0" title="0">{
                                missingPaths[path] = true
                        }</span>
                }
        }

        // Convert missing paths to stories by finding them in source
        <span class="cov0" title="0">var missingFolders []sb.Story
        sourceMap := make(map[string]sb.Story)
        for _, story := range pp.sourceStories </span><span class="cov0" title="0">{
                sourceMap[story.FullSlug] = story
        }</span>

        <span class="cov0" title="0">for path := range missingPaths </span><span class="cov0" title="0">{
                if folder, exists := sourceMap[path]; exists &amp;&amp; folder.IsFolder </span><span class="cov0" title="0">{
                        log.Printf("DEBUG: Found missing folder path: %s", path)
                        missingFolders = append(missingFolders, folder)
                }</span>
        }

        <span class="cov0" title="0">return missingFolders</span>
}

// BuildTargetFolderMap creates a map of existing folders in target space for quick lookup
func (pp *PreflightPlanner) BuildTargetFolderMap() map[string]sb.Story <span class="cov0" title="0">{
        folderMap := make(map[string]sb.Story)
        for _, story := range pp.targetStories </span><span class="cov0" title="0">{
                if story.IsFolder </span><span class="cov0" title="0">{
                        folderMap[story.FullSlug] = story
                }</span>
        }
        <span class="cov0" title="0">return folderMap</span>
}

// ProcessTranslatedSlugs handles translated slug processing like the Storyblok CLI
func ProcessTranslatedSlugs(sourceStory sb.Story, existingStories []sb.Story) sb.Story <span class="cov8" title="1">{
        if len(sourceStory.TranslatedSlugs) == 0 </span><span class="cov8" title="1">{
                return sourceStory
        }</span>

        // Copy translated slugs and remove IDs
        <span class="cov0" title="0">translatedSlugs := make([]sb.TranslatedSlug, len(sourceStory.TranslatedSlugs))
        for i, ts := range sourceStory.TranslatedSlugs </span><span class="cov0" title="0">{
                translatedSlugs[i] = sb.TranslatedSlug{
                        Lang: ts.Lang,
                        Name: ts.Name,
                        Path: ts.Path,
                }
        }</span>

        // If there's an existing story, merge the translated slug IDs
        <span class="cov0" title="0">if len(existingStories) &gt; 0 </span><span class="cov0" title="0">{
                existingStory := existingStories[0]
                if len(existingStory.TranslatedSlugs) &gt; 0 </span><span class="cov0" title="0">{
                        for i := range translatedSlugs </span><span class="cov0" title="0">{
                                for _, existingTS := range existingStory.TranslatedSlugs </span><span class="cov0" title="0">{
                                        if translatedSlugs[i].Lang == existingTS.Lang </span><span class="cov0" title="0">{
                                                translatedSlugs[i].ID = existingTS.ID
                                                break</span>
                                        }
                                }
                        }
                }
        }

        // Set the attributes for the API call
        <span class="cov0" title="0">sourceStory.TranslatedSlugsAttributes = translatedSlugs
        sourceStory.TranslatedSlugs = nil // Clear the original field

        return sourceStory</span>
}

// ParentSlug extracts the parent folder slug from a full slug
func ParentSlug(slug string) string <span class="cov8" title="1">{
        slashIdx := strings.LastIndex(slug, "/")
        if slashIdx == -1 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return slug[:slashIdx]</span>
}

// ItemType returns a string describing the item type for logging
func ItemType(story sb.Story) string <span class="cov8" title="1">{
        if story.IsFolder </span><span class="cov8" title="1">{
                return "folder"
        }</span>
        <span class="cov8" title="1">return "story"</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package sync

import (
        "context"
        "encoding/json"
        "log"
        "time"

        "storyblok-sync/internal/sb"
)

// StorySyncer handles story and folder synchronization operations
type StorySyncer struct {
        api           SyncAPI
        contentMgr    *ContentManager
        sourceSpaceID int
        targetSpaceID int
}

// NewStorySyncer creates a new story synchronizer
func NewStorySyncer(api SyncAPI, sourceSpaceID, targetSpaceID int) *StorySyncer <span class="cov8" title="1">{
        return &amp;StorySyncer{
                api:           api,
                contentMgr:    NewContentManager(api, sourceSpaceID),
                sourceSpaceID: sourceSpaceID,
                targetSpaceID: targetSpaceID,
        }
}</span>

// SyncStory synchronizes a single story
func (ss *StorySyncer) SyncStory(ctx context.Context, story sb.Story, shouldPublish bool) (sb.Story, error) <span class="cov8" title="1">{
        log.Printf("Syncing story: %s", story.FullSlug)

        // Ensure content is loaded
        fullStory, err := ss.contentMgr.EnsureContent(ctx, story)
        if err != nil </span><span class="cov8" title="1">{
                return sb.Story{}, err
        }</span>

        // Ensure non-folder stories have default content
        <span class="cov8" title="1">fullStory = EnsureDefaultContent(fullStory)

        // Check if story already exists in target
        existing, err := ss.api.GetStoriesBySlug(ctx, ss.targetSpaceID, story.FullSlug)
        if err != nil </span><span class="cov0" title="0">{
                return sb.Story{}, err
        }</span>

        // Resolve parent folder ID if needed
        <span class="cov8" title="1">fullStory = ss.resolveParentFolder(ctx, fullStory)

        // Handle translated slugs
        fullStory = ProcessTranslatedSlugs(fullStory, existing)

        if len(existing) &gt; 0 </span><span class="cov8" title="1">{
                // Update existing story
                existingStory := existing[0]
                updateStory := PrepareStoryForUpdate(fullStory, existingStory)

                updated, err := ss.api.UpdateStory(ctx, ss.targetSpaceID, updateStory, shouldPublish)
                if err != nil </span><span class="cov0" title="0">{
                        return sb.Story{}, err
                }</span>

                // Update UUID if different
                <span class="cov8" title="1">if updated.UUID != fullStory.UUID &amp;&amp; fullStory.UUID != "" </span><span class="cov8" title="1">{
                        if err := ss.api.UpdateStoryUUID(ctx, ss.targetSpaceID, updated.ID, fullStory.UUID); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to update UUID for story %s: %v", fullStory.FullSlug, err)
                        }</span>
                }

                <span class="cov8" title="1">log.Printf("Updated story: %s", fullStory.FullSlug)
                return updated, nil</span>
        } else<span class="cov8" title="1"> {
                // Create new story
                createStory := PrepareStoryForCreation(fullStory)

                created, err := ss.api.CreateStoryWithPublish(ctx, ss.targetSpaceID, createStory, shouldPublish)
                if err != nil </span><span class="cov0" title="0">{
                        return sb.Story{}, err
                }</span>

                <span class="cov8" title="1">log.Printf("Created story: %s", fullStory.FullSlug)
                return created, nil</span>
        }
}

// SyncFolder synchronizes a single folder
func (ss *StorySyncer) SyncFolder(ctx context.Context, folder sb.Story, shouldPublish bool) (sb.Story, error) <span class="cov8" title="1">{
        log.Printf("Syncing folder: %s", folder.FullSlug)

        // Ensure content is loaded for folder
        fullFolder, err := ss.contentMgr.EnsureContent(ctx, folder)
        if err != nil </span><span class="cov0" title="0">{
                // If content loading fails, use folder as-is with minimal content
                fullFolder = folder
                if len(fullFolder.Content) == 0 </span><span class="cov0" title="0">{
                        fullFolder.Content = json.RawMessage([]byte(`{}`))
                }</span>
        }

        // Debug logging
        <span class="cov8" title="1">log.Printf("DEBUG: syncFolder %s has content: %t, is_folder: %t",
                folder.FullSlug, len(fullFolder.Content) &gt; 0, fullFolder.IsFolder)

        // Check if folder already exists in target
        existing, err := ss.api.GetStoriesBySlug(ctx, ss.targetSpaceID, folder.FullSlug)
        if err != nil </span><span class="cov0" title="0">{
                return sb.Story{}, err
        }</span>

        // Resolve parent folder ID if needed
        <span class="cov8" title="1">fullFolder = ss.resolveParentFolder(ctx, fullFolder)

        // Handle translated slugs
        fullFolder = ProcessTranslatedSlugs(fullFolder, existing)

        if len(existing) &gt; 0 </span><span class="cov8" title="1">{
                // Update existing folder
                existingFolder := existing[0]
                updateFolder := PrepareStoryForUpdate(fullFolder, existingFolder)

                updated, err := ss.api.UpdateStory(ctx, ss.targetSpaceID, updateFolder, shouldPublish)
                if err != nil </span><span class="cov0" title="0">{
                        return sb.Story{}, err
                }</span>

                // Update UUID if different
                <span class="cov8" title="1">if updated.UUID != fullFolder.UUID &amp;&amp; fullFolder.UUID != "" </span><span class="cov0" title="0">{
                        if err := ss.api.UpdateStoryUUID(ctx, ss.targetSpaceID, updated.ID, fullFolder.UUID); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: failed to update UUID for folder %s: %v", fullFolder.FullSlug, err)
                        }</span>
                }

                <span class="cov8" title="1">log.Printf("Updated folder: %s", fullFolder.FullSlug)
                return updated, nil</span>
        } else<span class="cov8" title="1"> {
                // Create new folder
                createFolder := PrepareStoryForCreation(fullFolder)

                // Ensure folders have proper content structure
                if createFolder.IsFolder &amp;&amp; len(createFolder.Content) == 0 </span><span class="cov0" title="0">{
                        createFolder.Content = json.RawMessage([]byte(`{}`))
                }</span>

                <span class="cov8" title="1">created, err := ss.api.CreateStoryWithPublish(ctx, ss.targetSpaceID, createFolder, shouldPublish)
                if err != nil </span><span class="cov0" title="0">{
                        return sb.Story{}, err
                }</span>

                <span class="cov8" title="1">log.Printf("Created folder: %s", fullFolder.FullSlug)
                return created, nil</span>
        }
}

// SyncStoryDetailed synchronizes a story and returns detailed result
func (ss *StorySyncer) SyncStoryDetailed(story sb.Story, shouldPublish bool) (*SyncItemResult, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        targetStory, err := ss.SyncStory(ctx, story, shouldPublish)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine operation type based on whether story existed
        <span class="cov8" title="1">operation := OperationCreate
        existing, _ := ss.api.GetStoriesBySlug(ctx, ss.targetSpaceID, story.FullSlug)
        if len(existing) &gt; 0 </span><span class="cov0" title="0">{
                operation = OperationUpdate
        }</span>

        <span class="cov8" title="1">return &amp;SyncItemResult{
                Operation:   operation,
                TargetStory: &amp;targetStory,
                Warning:     "",
        }, nil</span>
}

// SyncFolderDetailed synchronizes a folder and returns detailed result
func (ss *StorySyncer) SyncFolderDetailed(folder sb.Story, shouldPublish bool) (*SyncItemResult, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        targetFolder, err := ss.SyncFolder(ctx, folder, shouldPublish)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Determine operation type based on whether folder existed
        <span class="cov0" title="0">operation := OperationCreate
        existing, _ := ss.api.GetStoriesBySlug(ctx, ss.targetSpaceID, folder.FullSlug)
        if len(existing) &gt; 0 </span><span class="cov0" title="0">{
                operation = OperationUpdate
        }</span>

        <span class="cov0" title="0">return &amp;SyncItemResult{
                Operation:   operation,
                TargetStory: &amp;targetFolder,
                Warning:     "",
        }, nil</span>
}

// resolveParentFolder resolves and sets the correct parent folder ID for a story
func (ss *StorySyncer) resolveParentFolder(ctx context.Context, story sb.Story) sb.Story <span class="cov8" title="1">{
        if story.FolderID == nil </span><span class="cov8" title="1">{
                return story
        }</span>

        <span class="cov8" title="1">parentSlugStr := ParentSlug(story.FullSlug)
        if parentSlugStr == "" </span><span class="cov0" title="0">{
                story.FolderID = nil
                return story
        }</span>

        <span class="cov8" title="1">targetParents, err := ss.api.GetStoriesBySlug(ctx, ss.targetSpaceID, parentSlugStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to resolve parent folder for %s: %v", story.FullSlug, err)
                return story
        }</span>

        <span class="cov8" title="1">if len(targetParents) &gt; 0 </span><span class="cov8" title="1">{
                story.FolderID = &amp;targetParents[0].ID
        }</span> else<span class="cov8" title="1"> {
                story.FolderID = nil
                log.Printf("Warning: Parent folder %s not found in target space for %s", parentSlugStr, story.FullSlug)
        }</span>

        <span class="cov8" title="1">return story</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package sync

import (
        "encoding/json"
        "log"
        "strings"

        "storyblok-sync/internal/sb"
)

// Constants for sync operations
const (
        DefaultComponent = "page"
        OperationCreate  = "create"
        OperationUpdate  = "update"
        OperationSkip    = "skip"
)

// PrepareStoryForCreation prepares a story for creation by clearing read-only fields
func PrepareStoryForCreation(story sb.Story) sb.Story <span class="cov8" title="1">{
        story.ID = 0
        story.CreatedAt = ""
        story.UpdatedAt = ""
        return story
}</span>

// PrepareStoryForUpdate prepares a story for update by preserving necessary fields
func PrepareStoryForUpdate(source, target sb.Story) sb.Story <span class="cov8" title="1">{
        // Keep target's ID and timestamps, but use source's content
        source.ID = target.ID
        source.CreatedAt = target.CreatedAt
        // Don't set UpdatedAt - let API handle it
        source.UpdatedAt = ""
        return source
}</span>

// EnsureDefaultContent ensures non-folder stories have content
func EnsureDefaultContent(story sb.Story) sb.Story <span class="cov8" title="1">{
        if !story.IsFolder &amp;&amp; len(story.Content) == 0 </span><span class="cov8" title="1">{
                // {"component":"page"}
                contentBytes, _ := json.Marshal(map[string]interface{}{
                        "component": DefaultComponent,
                })
                story.Content = json.RawMessage(contentBytes)
        }</span>
        <span class="cov8" title="1">return story</span>
}

// GetContentKeys extracts keys from a JSON content blob for debugging
func GetContentKeys(content json.RawMessage) []string <span class="cov0" title="0">{
        if len(content) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var tmp map[string]interface{}
        if err := json.Unmarshal(content, &amp;tmp); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">keys := make([]string, 0, len(tmp))
        for k := range tmp </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// GetContentField returns an arbitrary field from JSON content as interface{}
func GetContentField(content json.RawMessage, key string) (interface{}, bool) <span class="cov0" title="0">{
        if len(content) == 0 </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">var tmp map[string]interface{}
        if err := json.Unmarshal(content, &amp;tmp); err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">v, ok := tmp[key]
        return v, ok</span>
}

// GetFolderPaths extracts all parent folder paths from a story slug
func GetFolderPaths(slug string) []string <span class="cov8" title="1">{
        parts := strings.Split(slug, "/")
        if len(parts) &lt;= 1 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">paths := make([]string, 0, len(parts)-1)
        for i := 1; i &lt; len(parts); i++ </span><span class="cov8" title="1">{
                path := strings.Join(parts[:i], "/")
                if path != "" </span><span class="cov8" title="1">{
                        paths = append(paths, path)
                }</span>
        }
        <span class="cov8" title="1">return paths</span>
}

// LogError logs comprehensive error information for debugging
func LogError(operation, slug string, err error, story *sb.Story) <span class="cov0" title="0">{
        log.Printf("ERROR: %s failed for %s: %v", operation, slug, err)

        if story != nil </span><span class="cov0" title="0">{
                // Log story context
                log.Printf("ERROR CONTEXT for %s:", slug)
                log.Printf("  Story ID: %d", story.ID)
                log.Printf("  Story UUID: %s", story.UUID)
                log.Printf("  Story Name: %s", story.Name)
                log.Printf("  Full Slug: %s", story.FullSlug)
                log.Printf("  Is Folder: %t", story.IsFolder)
                log.Printf("  Published: %t", story.Published)

                if story.FolderID != nil </span><span class="cov0" title="0">{
                        log.Printf("  Parent ID: %d", *story.FolderID)
                }</span>

                <span class="cov0" title="0">if len(story.TagList) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("  Tags: %v", story.TagList)
                }</span>

                <span class="cov0" title="0">if len(story.TranslatedSlugs) &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("  Translated Slugs: %d entries", len(story.TranslatedSlugs))
                        for _, ts := range story.TranslatedSlugs </span><span class="cov0" title="0">{
                                log.Printf("    - %s: %s (%s)", ts.Lang, ts.Name, ts.Path)
                        }</span>
                }

                // Log content summary (first level keys only, to avoid huge logs)
                <span class="cov0" title="0">if len(story.Content) &gt; 0 </span><span class="cov0" title="0">{
                        contentKeys := GetContentKeys(story.Content)
                        log.Printf("  Content Keys: %v", contentKeys)

                        // Log component type if available
                        if v, ok := GetContentField(story.Content, "component"); ok </span><span class="cov0" title="0">{
                                if component, _ := v.(string); component != "" </span><span class="cov0" title="0">{
                                        log.Printf("  Component Type: %s", component)
                                }</span>
                        }
                }

                // Log full story as JSON for complete debugging (only if content is small enough)
                <span class="cov0" title="0">if storyJSON, err := json.Marshal(story); err == nil </span><span class="cov0" title="0">{
                        if len(storyJSON) &lt; 2000 </span><span class="cov0" title="0">{ // Only log if less than 2KB
                                log.Printf("  Full Story JSON: %s", string(storyJSON))
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("  Full Story JSON: [too large, %d bytes - see report file]", len(storyJSON))
                        }</span>
                }
        }

        // Log additional error context if available
        <span class="cov0" title="0">logExtendedErrorContext(err)</span>
}

// LogWarning logs comprehensive warning information
func LogWarning(operation, slug, warning string, story *sb.Story) <span class="cov0" title="0">{
        log.Printf("WARNING: %s for %s: %s", operation, slug, warning)

        if story != nil </span><span class="cov0" title="0">{
                log.Printf("WARNING CONTEXT for %s:", slug)
                log.Printf("  Story ID: %d (UUID: %s)", story.ID, story.UUID)
                log.Printf("  Full Slug: %s", story.FullSlug)
                if story.FolderID != nil </span><span class="cov0" title="0">{
                        log.Printf("  Parent ID: %d", *story.FolderID)
                }</span>
        }
}

// LogSuccess logs success with context information
func LogSuccess(operation, slug string, duration int64, targetStory *sb.Story) <span class="cov0" title="0">{
        log.Printf("SUCCESS: %s completed for %s in %dms", operation, slug, duration)

        if targetStory != nil </span><span class="cov0" title="0">{
                log.Printf("SUCCESS CONTEXT for %s:", slug)
                log.Printf("  Created/Updated Story ID: %d (UUID: %s)", targetStory.ID, targetStory.UUID)
                if targetStory.FolderID != nil </span><span class="cov0" title="0">{
                        log.Printf("  Parent ID: %d", *targetStory.FolderID)
                }</span>
                <span class="cov0" title="0">log.Printf("  Published: %t", targetStory.Published)</span>
        }
}

// logExtendedErrorContext extracts and logs additional context from errors
func logExtendedErrorContext(err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">errStr := err.Error()

        // Check for common API error patterns and log additional context
        if strings.Contains(errStr, "status") </span><span class="cov0" title="0">{
                log.Printf("  HTTP Error Details: %s", errStr)
        }</span>

        <span class="cov0" title="0">if strings.Contains(errStr, "timeout") </span><span class="cov0" title="0">{
                log.Printf("  Timeout Error - this may indicate network issues or server overload")
        }</span>

        <span class="cov0" title="0">if strings.Contains(errStr, "401") || strings.Contains(errStr, "403") </span><span class="cov0" title="0">{
                log.Printf("  Authentication/Authorization Error - check token permissions")
        }</span>

        <span class="cov0" title="0">if strings.Contains(errStr, "404") </span><span class="cov0" title="0">{
                log.Printf("  Resource Not Found - story or space may not exist")
        }</span>

        <span class="cov0" title="0">if strings.Contains(errStr, "429") </span><span class="cov0" title="0">{
                log.Printf("  Rate Limited - will retry with backoff")
        }</span>

        <span class="cov0" title="0">if strings.Contains(errStr, "500") || strings.Contains(errStr, "502") || strings.Contains(errStr, "503") </span><span class="cov0" title="0">{
                log.Printf("  Server Error - this may be temporary, will retry")
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package ui

import (
        "strings"

        tree "github.com/charmbracelet/lipgloss/tree"
        "storyblok-sync/internal/sb"
)

// generateTreeLinesFromStories builds a tree for a flat, ordered slice of stories
// and returns the rendered lines. The input order defines sibling ordering.
// generateTreeLinesLabeled builds a tree using a caller-provided label function.
func generateTreeLinesLabeled(stories []sb.Story, labelFn func(i int, st sb.Story) string) []string <span class="cov8" title="1">{
        if len(stories) == 0 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov8" title="1">tr := tree.New()
        nodes := make(map[int]*tree.Tree, len(stories))

        // First pass: create all nodes
        for i, st := range stories </span><span class="cov8" title="1">{
                node := tree.Root(labelFn(i, st))
                nodes[st.ID] = node
        }</span>

        // Second pass: attach children to parents, otherwise add as root child
        <span class="cov8" title="1">for _, st := range stories </span><span class="cov8" title="1">{
                node := nodes[st.ID]
                if st.FolderID != nil </span><span class="cov8" title="1">{
                        if parent, ok := nodes[*st.FolderID]; ok </span><span class="cov8" title="1">{
                                parent.Child(node)
                                continue</span>
                        }
                }
                <span class="cov8" title="1">tr.Child(node)</span>
        }

        <span class="cov8" title="1">lines := strings.Split(tr.String(), "\n")
        if len(lines) &gt; 0 &amp;&amp; lines[len(lines)-1] == "" </span><span class="cov0" title="0">{
                lines = lines[:len(lines)-1]
        }</span>
        <span class="cov8" title="1">return lines</span>
}

// generateTreeLinesFromStories builds tree lines using the default story display label.
func generateTreeLinesFromStories(stories []sb.Story) []string <span class="cov8" title="1">{
        return generateTreeLinesLabeled(stories, func(_ int, st sb.Story) string </span><span class="cov8" title="1">{ return displayStory(st) }</span>)
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package ui

import (
        "context"
        "storyblok-sync/internal/config"
        "storyblok-sync/internal/sb"

        "github.com/charmbracelet/bubbles/spinner"
        "github.com/charmbracelet/bubbles/textinput"
        "github.com/charmbracelet/bubbles/viewport"
)

// --- Model / State ---
type state int

const (
        stateWelcome state = iota
        stateTokenPrompt
        stateValidating
        stateSpaceSelect
        stateScanning
        stateBrowseList
        statePreflight
        stateSync
        stateReport
        stateQuit
)

type SelectionState struct {
        // browse list (source)
        listIndex int
        selected  map[string]bool // key: FullSlug (oder Full Path)
}

type FilterState struct {
        // prefix-filter
        prefixing   bool
        prefixInput textinput.Model
        prefix      string // z.B. "a__portal/de"
}

type SearchState struct {
        // searching
        searching   bool
        searchInput textinput.Model
        query       string // aktueller Suchstring
        filteredIdx []int  // Mapping: sichtbarer Index -&gt; original Index
}

// SyncState represents the action that will be performed for a story.
// It is kept as a string to allow easy extension with additional states.
type SyncState string

const (
        StateCreate SyncState = "C"
        StateUpdate SyncState = "U"
        StateSkip   SyncState = "S"
)

// RunState marks the execution state of a sync item.
type RunState int

const (
        RunPending RunState = iota
        RunRunning
        RunDone
        RunCancelled
)

type PreflightItem struct {
        Story      sb.Story
        Collision  bool
        Skip       bool
        Selected   bool
        State      SyncState
        StartsWith bool
        Run        RunState
}

func (it *PreflightItem) RecalcState() <span class="cov8" title="1">{
        switch </span>{
        case it.Skip:<span class="cov8" title="1">
                it.State = StateSkip</span>
        case it.Collision:<span class="cov8" title="1">
                it.State = StateUpdate</span>
        default:<span class="cov8" title="1">
                it.State = StateCreate</span>
        }
}

type PreflightState struct {
        items     []PreflightItem
        listIndex int
        // visibleIdx maps visible list positions to indices in items
        // to support folder collapse/expand like in browse view
        visibleIdx []int
}

type SyncPlan struct {
        Items []PreflightItem
}

type Model struct {
        state         state
        cfg           config.Config
        hasSBRC       bool
        sbrcPath      string
        statusMsg     string
        validateErr   error
        width, height int

        // viewport for scrollable content
        viewport viewport.Model

        // spinner for loading states
        spinner     spinner.Model
        syncing     bool
        syncIndex   int
        syncCancel  context.CancelFunc // for cancelling sync operations
        syncContext context.Context    // cancellable context for sync
        api         *sb.Client
        report      Report

        // token input
        ti textinput.Model

        // spaces &amp; selection
        spaces          []sb.Space
        selectedIndex   int
        selectingSource bool
        sourceSpace     *sb.Space
        targetSpace     *sb.Space

        // scan results
        storiesSource []sb.Story
        storiesTarget []sb.Story

        // tree state
        storyIdx        map[int]int  // Story ID -&gt; index in storiesSource
        folderCollapsed map[int]bool // Folder ID -&gt; collapsed?
        visibleIdx      []int        // indices of visible storiesSource entries

        selection SelectionState
        filter    FilterState
        search    SearchState
        filterCfg FilterConfig // Konfiguration für Such- und Filterparameter

        preflight PreflightState
        plan      SyncPlan

        // preserve browse collapse state when entering preflight
        collapsedBeforePreflight map[int]bool
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package ui

import (
        "fmt"

        "github.com/charmbracelet/bubbles/spinner"
        tea "github.com/charmbracelet/bubbletea"

        "storyblok-sync/internal/config"
)

// ---------- Update ----------
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{

        case tea.KeyMsg:<span class="cov8" title="1">
                key := msg.String()
                if m.state == statePreflight </span><span class="cov0" title="0">{
                        return m.handlePreflightKey(msg)
                }</span>

                // global shortcuts
                <span class="cov8" title="1">if key == "ctrl+c" </span><span class="cov0" title="0">{
                        // If we're syncing, cancel the sync operations
                        if m.syncing &amp;&amp; m.syncCancel != nil </span><span class="cov0" title="0">{
                                m.syncCancel()
                                m.statusMsg = "Sync cancelled by user (Ctrl+C)"
                                return m, nil
                        }</span>
                        <span class="cov0" title="0">return m, tea.Quit</span>
                }
                <span class="cov8" title="1">if key == "q" </span><span class="cov8" title="1">{
                        return m, tea.Quit
                }</span>

                <span class="cov0" title="0">switch m.state </span>{
                case stateWelcome:<span class="cov0" title="0">
                        return m.handleWelcomeKey(key)</span>
                case stateTokenPrompt:<span class="cov0" title="0">
                        return m.handleTokenPromptKey(msg)</span>
                case stateValidating:<span class="cov0" title="0">
                        return m.handleValidatingKey(key)</span>
                case stateSpaceSelect:<span class="cov0" title="0">
                        return m.handleSpaceSelectKey(key)</span>
                case stateScanning:<span class="cov0" title="0">
                        return m.handleScanningKey(key)</span>
                case stateBrowseList:<span class="cov0" title="0">
                        return m.handleBrowseListKey(msg)</span>
                case stateSync:<span class="cov0" title="0">
                        return m.handleSyncKey(key)</span>
                case stateReport:<span class="cov0" title="0">
                        return m.handleReportKey(key)</span>
                }

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width, m.height = msg.Width, msg.Height

                // Update viewport dimensions
                headerHeight := 3 // title + divider + state header
                footerHeight := 3 // help text lines
                viewportHeight := msg.Height - headerHeight - footerHeight
                if viewportHeight &lt; 5 </span><span class="cov0" title="0">{
                        viewportHeight = 5
                }</span>
                <span class="cov0" title="0">m.viewport.Width = msg.Width
                m.viewport.Height = viewportHeight

                // BubbleTea viewport handles all scrolling now

                // Update viewport content after resize
                m.updateViewportContent()</span>

        case validateMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.validateErr = msg.err
                        m.statusMsg = "Validierung fehlgeschlagen: " + msg.err.Error()
                        m.state = stateTokenPrompt
                        return m, nil
                }</span>
                <span class="cov0" title="0">m.spaces = msg.spaces

                // Save token to .sbrc file after successful validation
                if err := config.Save(m.cfg.Path, m.cfg); err != nil </span><span class="cov0" title="0">{
                        m.statusMsg = "Token validiert, aber Speichern fehlgeschlagen: " + err.Error()
                }</span> else<span class="cov0" title="0"> {
                        m.statusMsg = fmt.Sprintf("Token gespeichert. %d Spaces gefunden.", len(m.spaces))
                }</span>
                // check if we have spaces configured and validate if their ids are in m.spaces
                <span class="cov0" title="0">if m.cfg.SourceSpace != "" &amp;&amp; m.cfg.TargetSpace != "" </span><span class="cov0" title="0">{
                        sourceSpace, sourceIdIsOk := containsSpaceID(m.spaces, m.cfg.SourceSpace)
                        targetSpace, targetIdIsOk := containsSpaceID(m.spaces, m.cfg.TargetSpace)

                        if sourceIdIsOk &amp;&amp; targetIdIsOk </span><span class="cov0" title="0">{
                                m.sourceSpace = &amp;sourceSpace
                                m.targetSpace = &amp;targetSpace
                                m.statusMsg = fmt.Sprintf("Target gesetzt: %s (%d). Scanne jetzt Stories…", sourceSpace.Name, sourceSpace.ID)
                                m.state = stateScanning
                                return m, tea.Batch(m.spinner.Tick, m.scanStoriesCmd())
                        }</span>
                }
                <span class="cov0" title="0">m.state = stateSpaceSelect
                m.selectingSource = true
                m.selectedIndex = 0
                return m, nil</span>

        case scanMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.statusMsg = "Scan-Fehler: " + msg.err.Error()
                        m.state = stateSpaceSelect // zurück; du kannst auch einen Fehler-Screen bauen
                        return m, nil
                }</span>
                <span class="cov0" title="0">m.storiesSource = msg.src
                m.storiesTarget = msg.tgt
                m.selection.listIndex = 0
                m.rebuildStoryIndex()
                m.applyFilter()
                if m.selection.selected == nil </span><span class="cov0" title="0">{
                        m.selection.selected = make(map[string]bool)
                }</span> else<span class="cov0" title="0"> {
                        // optional: Selektion leeren, da sich die Liste geändert hat
                        clear(m.selection.selected)
                }</span>
                <span class="cov0" title="0">m.statusMsg = fmt.Sprintf("Scan ok. Source: %d Stories, Target: %d Stories.", len(m.storiesSource), len(m.storiesTarget))
                m.state = stateBrowseList
                m.updateViewportContent()
                return m, nil</span>

        case spinner.TickMsg:<span class="cov0" title="0">
                if m.state == stateValidating || m.state == stateScanning || m.state == stateSync </span><span class="cov0" title="0">{
                        var cmd tea.Cmd
                        m.spinner, cmd = m.spinner.Update(msg)
                        return m, cmd
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        case syncResultMsg:<span class="cov0" title="0">
                if msg.Index &lt; len(m.preflight.items) </span><span class="cov0" title="0">{
                        if msg.Cancelled </span><span class="cov0" title="0">{
                                m.preflight.items[msg.Index].Run = RunCancelled
                                it := m.preflight.items[msg.Index]
                                m.report.AddError(it.Story.FullSlug, "cancelled", "Sync cancelled by user", 0, &amp;it.Story)

                                // Mark all remaining items as cancelled
                                for i := msg.Index + 1; i &lt; len(m.preflight.items); i++ </span><span class="cov0" title="0">{
                                        if m.preflight.items[i].Run == RunPending || m.preflight.items[i].Run == RunRunning </span><span class="cov0" title="0">{
                                                m.preflight.items[i].Run = RunCancelled
                                                it := m.preflight.items[i]
                                                m.report.AddError(it.Story.FullSlug, "cancelled", "Sync cancelled by user", 0, &amp;it.Story)
                                        }</span>
                                }

                                <span class="cov0" title="0">m.syncing = false
                                m.syncCancel = nil
                                m.syncContext = nil
                                m.statusMsg = "Sync cancelled - press 'r' to generate report"
                                return m, nil</span>
                        }

                        <span class="cov0" title="0">m.preflight.items[msg.Index].Run = RunDone
                        it := m.preflight.items[msg.Index]

                        if msg.Err != nil </span><span class="cov0" title="0">{
                                // Add error to report with complete source story
                                m.report.AddError(it.Story.FullSlug, "sync", msg.Err.Error(), msg.Duration, &amp;it.Story)
                        }</span> else<span class="cov0" title="0"> if msg.Result != nil </span><span class="cov0" title="0">{
                                // Add successful sync to report
                                if msg.Result.Warning != "" </span><span class="cov0" title="0">{
                                        // Success with warning
                                        m.report.AddWarning(it.Story.FullSlug, msg.Result.Operation, msg.Result.Warning, msg.Duration, &amp;it.Story, msg.Result.TargetStory)
                                }</span> else<span class="cov0" title="0"> {
                                        // Pure success
                                        m.report.AddSuccess(it.Story.FullSlug, msg.Result.Operation, msg.Duration, msg.Result.TargetStory)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Fallback for unexpected case
                                m.report.AddSuccess(it.Story.FullSlug, "unknown", msg.Duration, nil)
                        }</span>
                }

                <span class="cov0" title="0">done := 0
                cancelled := 0
                for _, it := range m.preflight.items </span><span class="cov0" title="0">{
                        if it.Run == RunDone </span><span class="cov0" title="0">{
                                done++
                        }</span> else<span class="cov0" title="0"> if it.Run == RunCancelled </span><span class="cov0" title="0">{
                                cancelled++
                        }</span>
                }
                <span class="cov0" title="0">m.syncIndex = done

                // Update viewport content to show progress in real-time
                if m.state == stateSync </span><span class="cov0" title="0">{
                        m.updateViewportContent()
                }</span>

                // Continue only if we haven't finished all items and haven't been cancelled
                <span class="cov0" title="0">if done+cancelled &lt; len(m.preflight.items) &amp;&amp; cancelled == 0 </span><span class="cov0" title="0">{
                        return m, m.runNextItem()
                }</span>

                <span class="cov0" title="0">m.syncing = false
                m.state = stateReport
                if cancelled &gt; 0 </span><span class="cov0" title="0">{
                        m.statusMsg = fmt.Sprintf("Sync cancelled - %d completed, %d cancelled", done, cancelled)
                }</span> else<span class="cov0" title="0"> {
                        m.statusMsg = m.report.GetDisplaySummary()
                }</span>
                <span class="cov0" title="0">_ = m.report.Save()

                // Update viewport content for report view
                m.updateViewportContent()
                return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package ui

import (
        "fmt"
        "strings"

        "storyblok-sync/internal/sb"
)

// ------ utils -------

func containsSpaceID(spacesSlice []sb.Space, spaceID string) (sb.Space, bool) <span class="cov8" title="1">{
        for _, space := range spacesSlice </span><span class="cov8" title="1">{
                if fmt.Sprint(space.ID) == spaceID </span><span class="cov8" title="1">{
                        return space, true
                }</span>
        }
        <span class="cov8" title="1">return sb.Space{}, false</span>
}

func (m *Model) indexBySlug(slug string) int <span class="cov8" title="1">{
        for i, st := range m.storiesSource </span><span class="cov8" title="1">{
                if st.FullSlug == slug </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func (m *Model) includeAncestors(idx int, inc map[int]bool) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                if inc[idx] </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">inc[idx] = true
                st := m.storiesSource[idx]
                if st.FolderID == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">pIdx, ok := m.storyIdx[*st.FolderID]
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">idx = pIdx</span>
        }
}

func (m *Model) rebuildStoryIndex() <span class="cov8" title="1">{
        m.storyIdx = make(map[int]int, len(m.storiesSource))
        m.folderCollapsed = make(map[int]bool)
        for i, st := range m.storiesSource </span><span class="cov8" title="1">{
                m.storyIdx[st.ID] = i
                if st.IsFolder </span><span class="cov8" title="1">{
                        m.folderCollapsed[st.ID] = true
                }</span>
        }
}

func (m Model) hasSelectedDescendant(slug string) bool <span class="cov8" title="1">{
        prefix := slug + "/"
        for s, v := range m.selection.selected </span><span class="cov8" title="1">{
                if v &amp;&amp; strings.HasPrefix(s, prefix) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (m Model) hasSelectedDirectChild(slug string) bool <span class="cov8" title="1">{
        prefix := slug + "/"
        for s, v := range m.selection.selected </span><span class="cov8" title="1">{
                if v &amp;&amp; strings.HasPrefix(s, prefix) </span><span class="cov8" title="1">{
                        rest := strings.TrimPrefix(s, prefix)
                        if !strings.Contains(rest, "/") </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package ui

import (
        "fmt"
        "storyblok-sync/internal/sb"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

func (m *Model) updateBrowseViewport() <span class="cov8" title="1">{
        content := m.renderBrowseContent()
        m.viewport.SetContent(content)
}</span>

func (m Model) renderBrowseHeader() string <span class="cov0" title="0">{
        srcCount := len(m.storiesSource)
        tgtCount := len(m.storiesTarget)

        var b strings.Builder
        b.WriteString(fmt.Sprintf("Browse (Source Stories) – %d Items  |  Target: %d\n", srcCount, tgtCount))

        // Search and filter status
        label := "Suche: "
        if m.search.searching </span><span class="cov0" title="0">{
                b.WriteString(label + m.search.searchInput.View() + "  |  ")
        }</span> else<span class="cov0" title="0"> {
                b.WriteString(label + m.search.query + "  |  ")
        }</span>

        <span class="cov0" title="0">if m.filter.prefixing </span><span class="cov0" title="0">{
                b.WriteString("Prefix: " + m.filter.prefixInput.View())
        }</span> else<span class="cov0" title="0"> {
                b.WriteString(subtleStyle.Render("Prefix:" + m.filter.prefix))
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func (m Model) renderBrowseContent() string <span class="cov8" title="1">{
        var b strings.Builder
        srcCount := len(m.storiesSource)

        if srcCount == 0 </span><span class="cov0" title="0">{
                b.WriteString(warnStyle.Render("Keine Stories im Source gefunden.") + "\n")
                return b.String()
        }</span>

        <span class="cov8" title="1">total := m.itemsLen()
        if total == 0 </span><span class="cov8" title="1">{
                b.WriteString(warnStyle.Render("Keine Stories gefunden (Filter aktiv?).") + "\n")
                return b.String()
        }</span>

        // Sammle sichtbare Stories (shared helper)
        <span class="cov8" title="1">stories, _ := m.visibleOrderBrowse()

        // Erzeuge Tree-Struktur (shared helper)
        lines := generateTreeLinesFromStories(stories)

        for i, st := range stories </span><span class="cov8" title="1">{
                if i &gt;= len(lines) </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">content := lines[i]
                if i == m.selection.listIndex </span><span class="cov8" title="1">{
                        content = cursorLineStyle.Width(m.width - 4).Render(content)
                }</span> else<span class="cov8" title="1"> {
                        content = lipgloss.NewStyle().Width(m.width - 4).Render(content)
                }</span>

                <span class="cov8" title="1">cursorCell := " "
                if i == m.selection.listIndex </span><span class="cov8" title="1">{
                        cursorCell = cursorBarStyle.Render(" ")
                }</span>

                // Preflight has a stateCell; for consistency, browse also reserves a state cell.
                // Here we render selection mark into that cell and keep same width budget.
                <span class="cov8" title="1">stateCell := " "
                if m.selection.selected[st.FullSlug] </span><span class="cov8" title="1">{
                        stateCell = markBarStyle.Render(" ")
                }</span> else<span class="cov8" title="1"> if st.IsFolder </span><span class="cov8" title="1">{
                        if m.hasSelectedDirectChild(st.FullSlug) </span><span class="cov8" title="1">{
                                stateCell = markNestedStyle.Render(":")
                        }</span> else<span class="cov8" title="1"> if m.hasSelectedDescendant(st.FullSlug) </span><span class="cov8" title="1">{
                                stateCell = markNestedStyle.Render("·")
                        }</span>
                }

                <span class="cov8" title="1">lines[i] = cursorCell + stateCell + content</span>
        }

        <span class="cov8" title="1">b.WriteString(strings.Join(lines, "\n"))
        return b.String()</span>
}

func (m Model) renderBrowseFooter() string <span class="cov0" title="0">{
        total := m.itemsLen()
        checked := 0
        for _, v := range m.selection.selected </span><span class="cov0" title="0">{
                if v </span><span class="cov0" title="0">{
                        checked++
                }</span>
        }

        // Status info
        <span class="cov0" title="0">suffix := ""
        if m.search.filteredIdx != nil </span><span class="cov0" title="0">{
                suffix = fmt.Sprintf("  |  gefiltert: %d", total)
        }</span>
        <span class="cov0" title="0">statusLine := fmt.Sprintf("Total: %d | Markiert: %d%s", total, checked, suffix)

        return renderFooter(
                statusLine,
                "j/k bewegen  |  h/l falten  |  H alles zu  |  L alles auf  |  space Story markieren  |  r rescan  |  s preflight  |  q beenden",
                "p Prefix  |  P Prefix löschen  |  f suchen |  F Suche löschen  |  c Filter löschen  |  Enter schließen  |  Esc löschen/zurück",
        )</span>
}

func displayStory(st sb.Story) string <span class="cov8" title="1">{
        name := st.Name
        if name == "" </span><span class="cov0" title="0">{
                name = st.Slug
        }</span>
        <span class="cov8" title="1">sym := storyTypeSymbol(st)
        return fmt.Sprintf("%s %s  (%s)", sym, name, st.FullSlug)</span>
}

func storyTypeSymbol(st sb.Story) string <span class="cov8" title="1">{
        switch </span>{
        case st.IsFolder:<span class="cov8" title="1">
                return symbolFolder</span>
        case st.IsStartpage:<span class="cov0" title="0">
                return symbolRoot</span>
        default:<span class="cov8" title="1">
                return symbolStory</span>
        }
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package ui

import (
        "strings"

        "github.com/charmbracelet/lipgloss"
)

func (m Model) View() string <span class="cov0" title="0">{
        if m.state == stateQuit </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">header := m.renderHeader()
        footer := m.renderFooter()

        // States that use viewport
        switch m.state </span>{
        case stateBrowseList, statePreflight, stateSync, stateReport:<span class="cov0" title="0">
                stateHeader := m.renderStateHeader()
                content := m.renderViewportContent()
                return lipgloss.JoinVertical(lipgloss.Left, header, stateHeader, content, footer)</span>
        default:<span class="cov0" title="0">
                // States that don't use viewport (full-screen content)
                var b strings.Builder
                switch m.state </span>{
                case stateWelcome:<span class="cov0" title="0">
                        b.WriteString(m.viewWelcome())</span>
                case stateTokenPrompt:<span class="cov0" title="0">
                        b.WriteString(m.viewTokenPrompt())</span>
                case stateValidating:<span class="cov0" title="0">
                        b.WriteString(m.viewValidating())</span>
                case stateSpaceSelect:<span class="cov0" title="0">
                        b.WriteString(m.viewSpaceSelect())</span>
                case stateScanning:<span class="cov0" title="0">
                        b.WriteString(m.viewScanning())</span>
                }
                <span class="cov0" title="0">return lipgloss.JoinVertical(lipgloss.Left, header, b.String(), footer)</span>
        }
}

func (m Model) renderHeader() string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString(titleStyle.Render("Storyblok Sync (TUI)"))
        b.WriteString("\n")
        b.WriteString(dividerStyle.Render(strings.Repeat("─", max(10, m.width-2))))
        b.WriteString("\n")
        return b.String()
}</span>

func (m Model) renderFooter() string <span class="cov0" title="0">{
        switch m.state </span>{
        case stateBrowseList:<span class="cov0" title="0">
                return m.renderBrowseFooter()</span>
        case statePreflight:<span class="cov0" title="0">
                return m.renderPreflightFooter()</span>
        case stateSync:<span class="cov0" title="0">
                return m.renderSyncFooter()</span>
        case stateReport:<span class="cov0" title="0">
                return m.renderReportFooter()</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func (m Model) renderStateHeader() string <span class="cov0" title="0">{
        switch m.state </span>{
        case stateBrowseList:<span class="cov0" title="0">
                return m.renderBrowseHeader()</span>
        case statePreflight:<span class="cov0" title="0">
                return m.renderPreflightHeader()</span>
        case stateSync:<span class="cov0" title="0">
                return m.renderSyncHeader()</span>
        case stateReport:<span class="cov0" title="0">
                return m.renderReportHeader()</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func (m *Model) updateViewportContent() <span class="cov8" title="1">{
        switch m.state </span>{
        case stateBrowseList:<span class="cov8" title="1">
                m.updateBrowseViewport()</span>
        case statePreflight:<span class="cov8" title="1">
                m.updatePreflightViewport()</span>
        case stateSync:<span class="cov0" title="0">
                m.updateSyncViewport()</span>
        case stateReport:<span class="cov0" title="0">
                m.updateReportViewport()</span>
        }
}

func (m Model) renderViewportContent() string <span class="cov8" title="1">{
        return m.viewport.View()
}</span>

func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package ui

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

// Preflight is rendered via viewport header/content/footer.

func displayPreflightItem(it PreflightItem) string <span class="cov8" title="1">{
        name := it.Story.Name
        if name == "" </span><span class="cov0" title="0">{
                name = it.Story.Slug
        }</span>
        <span class="cov8" title="1">slug := "(" + it.Story.FullSlug + ")"
        if !it.Selected || it.State == StateSkip </span><span class="cov8" title="1">{
                name = subtleStyle.Render(name)
                slug = subtleStyle.Render(slug)
        }</span>
        <span class="cov8" title="1">sym := storyTypeSymbol(it.Story)
        return fmt.Sprintf("%s %s  %s", sym, name, slug)</span>
}

func (m *Model) updatePreflightViewport() <span class="cov8" title="1">{
        content := m.renderPreflightContent()
        m.viewport.SetContent(content)
}</span>

func (m Model) renderPreflightHeader() string <span class="cov8" title="1">{
        total := len(m.preflight.items)
        collisions := 0
        for _, it := range m.preflight.items </span><span class="cov8" title="1">{
                if it.Collision </span><span class="cov0" title="0">{
                        collisions++
                }</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("Preflight – %d Items  |  Kollisionen: %d", total, collisions)</span>
}

func (m Model) renderPreflightContent() string <span class="cov8" title="1">{
        var b strings.Builder
        total := len(m.preflight.items)

        if total == 0 </span><span class="cov0" title="0">{
                b.WriteString(warnStyle.Render("Keine Stories markiert.") + "\n")
                return b.String()
        }</span>

        // Build stories slice in preflight visible order (shared helper)
        <span class="cov8" title="1">stories, order := m.visibleOrderPreflight()
        lines := generateTreeLinesFromStories(stories)
        for visPos, idx := range order </span><span class="cov8" title="1">{
                if visPos &gt;= len(lines) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">it := m.preflight.items[idx]
                content := lines[visPos]
                if it.Collision </span><span class="cov8" title="1">{
                        content = collisionSign + " " + content
                }</span> else<span class="cov8" title="1"> {
                        content = "  " + content
                }</span>
                <span class="cov8" title="1">lineStyle := lipgloss.NewStyle().Width(m.width - 4)
                if visPos == m.preflight.listIndex </span><span class="cov8" title="1">{
                        lineStyle = cursorLineStyle.Copy().Width(m.width - 4)
                }</span>
                <span class="cov8" title="1">if it.State == StateSkip </span><span class="cov8" title="1">{
                        lineStyle = lineStyle.Faint(true)
                }</span>
                <span class="cov8" title="1">content = lineStyle.Render(content)
                cursorCell := " "
                if visPos == m.preflight.listIndex </span><span class="cov8" title="1">{
                        cursorCell = cursorBarStyle.Render(" ")
                }</span>
                <span class="cov8" title="1">stateCell := " "
                switch it.Run </span>{
                case RunRunning:<span class="cov0" title="0">
                        stateCell = m.spinner.View()</span>
                case RunDone:<span class="cov0" title="0">
                        stateCell = stateDoneStyle.Render(string(it.State))</span>
                case RunCancelled:<span class="cov0" title="0">
                        stateCell = lipgloss.NewStyle().Foreground(lipgloss.Color("9")).Background(lipgloss.Color("0")).Bold(true).Render("X")</span>
                default:<span class="cov8" title="1">
                        if it.State != "" </span><span class="cov8" title="1">{
                                if st, ok := stateStyles[it.State]; ok </span><span class="cov8" title="1">{
                                        stateCell = st.Render(string(it.State))
                                }</span> else<span class="cov0" title="0"> {
                                        stateCell = string(it.State)
                                }</span>
                        }
                }
                <span class="cov8" title="1">lines[visPos] = cursorCell + stateCell + content</span>
        }
        <span class="cov8" title="1">b.WriteString(strings.Join(lines, "\n"))
        return b.String()</span>
}

func (m Model) renderPreflightFooter() string <span class="cov8" title="1">{
        var statusLine string
        if m.syncing </span><span class="cov0" title="0">{
                statusLine = renderProgress(m.syncIndex, len(m.preflight.items), m.width-2)
        }</span>

        <span class="cov8" title="1">var helpText string
        if m.syncing </span><span class="cov0" title="0">{
                helpText = "Syncing... | Ctrl+C to cancel"
        }</span> else<span class="cov8" title="1"> {
                helpText = "j/k bewegen  |  x skip  |  X alle skippen  |  c Skips entfernen  |  Enter OK  |  esc/q zurück"
        }</span>

        <span class="cov8" title="1">return renderFooter(statusLine, helpText)</span>
}

func renderProgress(done, total, width int) string <span class="cov0" title="0">{
        if total &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if width &lt;= 0 </span><span class="cov0" title="0">{
                width = 20
        }</span>
        <span class="cov0" title="0">filled := int(float64(done) / float64(total) * float64(width))
        if filled &gt; width </span><span class="cov0" title="0">{
                filled = width
        }</span>
        <span class="cov0" title="0">return "[" + strings.Repeat("#", filled) + strings.Repeat("-", width-filled) + fmt.Sprintf("] %d/%d", done, total)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package ui

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

func (m Model) viewReport() string <span class="cov0" title="0">{
        var b strings.Builder

        // Header with sync summary
        totalDuration := float64(m.report.Duration) / 1000.0
        b.WriteString(fmt.Sprintf("Sync Report – %s\n", m.report.GetDisplaySummary()))
        b.WriteString(fmt.Sprintf("Duration: %.2fs  |  Source: %s  |  Target: %s\n\n",
                totalDuration, m.report.SourceSpace, m.report.TargetSpace))

        // Statistics section with colored boxes
        successStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("10")).Bold(true)
        warningStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("11")).Bold(true)
        errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("9")).Bold(true)

        statsBox := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("240")).
                Padding(1, 2).
                Margin(0, 1)

        // Create stats content
        var stats strings.Builder
        stats.WriteString(successStyle.Render(fmt.Sprintf("✓ %d Success", m.report.Summary.Success)))
        if m.report.Summary.Warning &gt; 0 </span><span class="cov0" title="0">{
                stats.WriteString("  " + warningStyle.Render(fmt.Sprintf("⚠ %d Warnings", m.report.Summary.Warning)))
        }</span>
        <span class="cov0" title="0">if m.report.Summary.Failure &gt; 0 </span><span class="cov0" title="0">{
                stats.WriteString("  " + errorStyle.Render(fmt.Sprintf("✗ %d Failures", m.report.Summary.Failure)))
        }</span>
        <span class="cov0" title="0">stats.WriteString(fmt.Sprintf("\n%d Created  |  %d Updated  |  %d Skipped",
                m.report.Summary.Created, m.report.Summary.Updated, m.report.Summary.Skipped))

        b.WriteString(statsBox.Render(stats.String()))
        b.WriteString("\n\n")

        if len(m.report.Entries) == 0 </span><span class="cov0" title="0">{
                b.WriteString(subtleStyle.Render("No entries in report.") + "\n")
        }</span> else<span class="cov0" title="0"> {
                // Group entries by status for better organization
                var successes, warnings, failures []ReportEntry
                for _, entry := range m.report.Entries </span><span class="cov0" title="0">{
                        switch entry.Status </span>{
                        case "success":<span class="cov0" title="0">
                                successes = append(successes, entry)</span>
                        case "warning":<span class="cov0" title="0">
                                warnings = append(warnings, entry)</span>
                        case "failure":<span class="cov0" title="0">
                                failures = append(failures, entry)</span>
                        }
                }

                // Show failures first (most important)
                <span class="cov0" title="0">if len(failures) &gt; 0 </span><span class="cov0" title="0">{
                        b.WriteString(errorStyle.Render("⚠ FAILURES") + "\n")
                        for _, entry := range failures </span><span class="cov0" title="0">{
                                duration := fmt.Sprintf("%dms", entry.Duration)
                                b.WriteString(fmt.Sprintf("  %s %s (%s) %s - %s\n",
                                        symbolStory, entry.Slug, entry.Operation, duration, entry.Error))
                        }</span>
                        <span class="cov0" title="0">b.WriteString("\n")</span>
                }

                // Show warnings next
                <span class="cov0" title="0">if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                        b.WriteString(warningStyle.Render("⚠ WARNINGS") + "\n")
                        for _, entry := range warnings </span><span class="cov0" title="0">{
                                duration := fmt.Sprintf("%dms", entry.Duration)
                                b.WriteString(fmt.Sprintf("  %s %s (%s) %s - %s\n",
                                        symbolStory, entry.Slug, entry.Operation, duration, entry.Warning))
                        }</span>
                        <span class="cov0" title="0">b.WriteString("\n")</span>
                }

                // Show recent successes (limit to avoid clutter)
                <span class="cov0" title="0">if len(successes) &gt; 0 </span><span class="cov0" title="0">{
                        b.WriteString(successStyle.Render("✓ SUCCESSES") + " ")
                        if len(successes) &gt; 10 </span><span class="cov0" title="0">{
                                b.WriteString(subtleStyle.Render(fmt.Sprintf("(showing last 10 of %d)", len(successes))))
                        }</span>
                        <span class="cov0" title="0">b.WriteString("\n")

                        start := len(successes) - 10
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                        <span class="cov0" title="0">for i := start; i &lt; len(successes); i++ </span><span class="cov0" title="0">{
                                entry := successes[i]
                                duration := fmt.Sprintf("%dms", entry.Duration)
                                symbol := symbolStory
                                if entry.TargetStory != nil &amp;&amp; entry.TargetStory.IsFolder </span><span class="cov0" title="0">{
                                        symbol = symbolFolder
                                }</span>
                                <span class="cov0" title="0">b.WriteString(fmt.Sprintf("  %s %s (%s) %s\n",
                                        symbol, entry.Slug, entry.Operation, duration))</span>
                        }
                }
        }

        <span class="cov0" title="0">b.WriteString("\n")

        // Footer with actions
        if m.report.Summary.Failure &gt; 0 </span><span class="cov0" title="0">{
                b.WriteString(helpStyle.Render("r retry failures  |  enter back to scan  |  q exit"))
        }</span> else<span class="cov0" title="0"> {
                b.WriteString(helpStyle.Render("enter back to scan  |  q exit"))
        }</span>

        <span class="cov0" title="0">return b.String()</span>
}

func (m *Model) updateReportViewport() <span class="cov0" title="0">{
        content := m.renderReportContent()
        m.viewport.SetContent(content)
}</span>

func (m Model) renderReportHeader() string <span class="cov0" title="0">{
        totalDuration := float64(m.report.Duration) / 1000.0
        return fmt.Sprintf("Sync Report – %s | Duration: %.2fs | Source: %s | Target: %s",
                m.report.GetDisplaySummary(), totalDuration, m.report.SourceSpace, m.report.TargetSpace)
}</span>

func (m Model) renderReportContent() string <span class="cov0" title="0">{
        var b strings.Builder

        // Statistics section with colored boxes
        successStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("10")).Bold(true)
        warningStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("11")).Bold(true)
        errorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("9")).Bold(true)

        statsBox := lipgloss.NewStyle().
                Border(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color("240")).
                Padding(1, 2).
                Margin(0, 1)

        // Create stats content
        var stats strings.Builder
        stats.WriteString(successStyle.Render(fmt.Sprintf("✓ %d Success", m.report.Summary.Success)))
        if m.report.Summary.Warning &gt; 0 </span><span class="cov0" title="0">{
                stats.WriteString("  " + warningStyle.Render(fmt.Sprintf("⚠ %d Warnings", m.report.Summary.Warning)))
        }</span>
        <span class="cov0" title="0">if m.report.Summary.Failure &gt; 0 </span><span class="cov0" title="0">{
                stats.WriteString("  " + errorStyle.Render(fmt.Sprintf("✗ %d Failures", m.report.Summary.Failure)))
        }</span>
        <span class="cov0" title="0">stats.WriteString(fmt.Sprintf("\n%d Created  |  %d Updated  |  %d Skipped",
                m.report.Summary.Created, m.report.Summary.Updated, m.report.Summary.Skipped))

        b.WriteString(statsBox.Render(stats.String()))
        b.WriteString("\n\n")

        if len(m.report.Entries) == 0 </span><span class="cov0" title="0">{
                b.WriteString(subtleStyle.Render("No entries in report.") + "\n")
        }</span> else<span class="cov0" title="0"> {
                // Group entries by status for better organization
                var successes, warnings, failures []ReportEntry
                for _, entry := range m.report.Entries </span><span class="cov0" title="0">{
                        switch entry.Status </span>{
                        case "success":<span class="cov0" title="0">
                                successes = append(successes, entry)</span>
                        case "warning":<span class="cov0" title="0">
                                warnings = append(warnings, entry)</span>
                        case "failure":<span class="cov0" title="0">
                                failures = append(failures, entry)</span>
                        }
                }

                // Show failures first (most important)
                <span class="cov0" title="0">if len(failures) &gt; 0 </span><span class="cov0" title="0">{
                        b.WriteString(errorStyle.Render("⚠ FAILURES") + "\n")
                        for _, entry := range failures </span><span class="cov0" title="0">{
                                duration := fmt.Sprintf("%dms", entry.Duration)
                                b.WriteString(fmt.Sprintf("  %s %s (%s) %s - %s\n",
                                        symbolStory, entry.Slug, entry.Operation, duration, entry.Error))
                        }</span>
                        <span class="cov0" title="0">b.WriteString("\n")</span>
                }

                // Show warnings next
                <span class="cov0" title="0">if len(warnings) &gt; 0 </span><span class="cov0" title="0">{
                        b.WriteString(warningStyle.Render("⚠ WARNINGS") + "\n")
                        for _, entry := range warnings </span><span class="cov0" title="0">{
                                duration := fmt.Sprintf("%dms", entry.Duration)
                                b.WriteString(fmt.Sprintf("  %s %s (%s) %s - %s\n",
                                        symbolStory, entry.Slug, entry.Operation, duration, entry.Warning))
                        }</span>
                        <span class="cov0" title="0">b.WriteString("\n")</span>
                }

                // Show recent successes (limit to avoid clutter)
                <span class="cov0" title="0">if len(successes) &gt; 0 </span><span class="cov0" title="0">{
                        b.WriteString(successStyle.Render("✓ SUCCESSES") + " ")
                        if len(successes) &gt; 10 </span><span class="cov0" title="0">{
                                b.WriteString(subtleStyle.Render(fmt.Sprintf("(showing last 10 of %d)", len(successes))))
                        }</span>
                        <span class="cov0" title="0">b.WriteString("\n")

                        start := len(successes) - 10
                        if start &lt; 0 </span><span class="cov0" title="0">{
                                start = 0
                        }</span>
                        <span class="cov0" title="0">for i := start; i &lt; len(successes); i++ </span><span class="cov0" title="0">{
                                entry := successes[i]
                                duration := fmt.Sprintf("%dms", entry.Duration)
                                symbol := symbolStory
                                if entry.TargetStory != nil &amp;&amp; entry.TargetStory.IsFolder </span><span class="cov0" title="0">{
                                        symbol = symbolFolder
                                }</span>
                                <span class="cov0" title="0">b.WriteString(fmt.Sprintf("  %s %s (%s) %s\n",
                                        symbol, entry.Slug, entry.Operation, duration))</span>
                        }
                }
        }

        <span class="cov0" title="0">return b.String()</span>
}

func (m Model) renderReportFooter() string <span class="cov0" title="0">{
        var helpText string
        if m.report.Summary.Failure &gt; 0 </span><span class="cov0" title="0">{
                helpText = "r retry failures  |  enter back to scan  |  q exit"
        }</span> else<span class="cov0" title="0"> {
                helpText = "enter back to scan  |  q exit"
        }</span>
        <span class="cov0" title="0">return renderFooter("", helpText)</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package ui

import (
        "fmt"
        "strings"
)

func (m Model) viewWelcome() string <span class="cov0" title="0">{
        title := titleStyle.Render("🚀 Storyblok Sync")
        subtitle := subtitleStyle.Render("Synchronisiere Stories zwischen Spaces")

        var statusLines []string
        if m.cfg.Token != "" </span><span class="cov0" title="0">{
                statusLines = append(statusLines, okStyle.Render("✓ Token vorhanden"))
        }</span> else<span class="cov0" title="0"> {
                statusLines = append(statusLines, warnStyle.Render("⚠ Kein Token gefunden (~/.sbrc oder SB_TOKEN)"))
        }</span>

        <span class="cov0" title="0">if m.hasSBRC </span><span class="cov0" title="0">{
                statusLines = append(statusLines, subtleStyle.Render(fmt.Sprintf("📁 Konfiguration: %s", m.sbrcPath)))
        }</span>

        <span class="cov0" title="0">if m.statusMsg != "" </span><span class="cov0" title="0">{
                statusLines = append(statusLines, subtleStyle.Render(m.statusMsg))
        }</span>

        <span class="cov0" title="0">content := fmt.Sprintf("%s\n%s\n\n%s",
                title,
                subtitle,
                strings.Join(statusLines, "\n"))

        boxContent := welcomeBoxStyle.Render(content)
        help := renderFooter("", "⌨️  Enter: weiter  •  q: beenden")

        return centeredStyle.Width(m.width).Render(boxContent) + "\n\n" +
                centeredStyle.Width(m.width).Render(help)</span>
}

func (m Model) viewTokenPrompt() string <span class="cov0" title="0">{
        title := titleStyle.Render("🔑 Token Eingabe")
        prompt := subtitleStyle.Render("Bitte gib deinen Storyblok Management API Token ein")

        var errorMsg string
        if m.validateErr != nil </span><span class="cov0" title="0">{
                errorMsg = "\n" + errorStyle.Render("❌ "+m.validateErr.Error())
        }</span>

        <span class="cov0" title="0">content := fmt.Sprintf("%s\n%s\n\n%s%s",
                title,
                prompt,
                m.ti.View(),
                errorMsg)

        boxContent := welcomeBoxStyle.Render(content)
        help := renderFooter("", "⌨️  Enter: bestätigen  •  Esc: zurück")

        return centeredStyle.Width(m.width).Render(boxContent) + "\n\n" +
                centeredStyle.Width(m.width).Render(help)</span>
}

func (m Model) viewValidating() string <span class="cov0" title="0">{
        title := titleStyle.Render("⏳ Validierung läuft")
        content := fmt.Sprintf("%s\n\n%s %s",
                title,
                m.spinner.View(),
                subtitleStyle.Render("Validiere Token..."))

        boxContent := welcomeBoxStyle.Render(content)
        help := renderFooter("", "⌨️  q: abbrechen")

        return centeredStyle.Width(m.width).Render(boxContent) + "\n\n" +
                centeredStyle.Width(m.width).Render(help)
}</span>

func (m Model) viewSpaceSelect() string <span class="cov0" title="0">{
        var header string
        if m.selectingSource </span><span class="cov0" title="0">{
                header = listHeaderStyle.Render("🎯 Wähle Source Space")
        }</span> else<span class="cov0" title="0"> {
                header = listHeaderStyle.Render("🎯 Wähle Target Space")
                if m.sourceSpace != nil </span><span class="cov0" title="0">{
                        sourceInfo := subtleStyle.Render(fmt.Sprintf("✅ Source: %s (ID: %d)", m.sourceSpace.Name, m.sourceSpace.ID))
                        header += "\n" + sourceInfo + "\n"
                }</span>
        }

        <span class="cov0" title="0">var content strings.Builder
        if len(m.spaces) == 0 </span><span class="cov0" title="0">{
                content.WriteString(warnStyle.Render("❌ Keine Spaces gefunden"))
        }</span> else<span class="cov0" title="0"> {
                for i, sp := range m.spaces </span><span class="cov0" title="0">{
                        var line string
                        spaceInfo := fmt.Sprintf("%s (ID: %d)", sp.Name, sp.ID)

                        if i == m.selectedIndex </span><span class="cov0" title="0">{
                                line = spaceSelectedStyle.Render("▶ " + spaceInfo)
                        }</span> else<span class="cov0" title="0"> {
                                line = spaceItemStyle.Render("  " + spaceInfo)
                        }</span>
                        <span class="cov0" title="0">content.WriteString(line + "\n")</span>
                }
        }

        // Create footer that sits at the bottom
        <span class="cov0" title="0">footer := renderFooter("", "⌨️  ↑↓/j/k: navigieren  •  Enter: auswählen  •  q: beenden")

        // Calculate available height for content (total height - header - footer - margins)
        contentHeight := m.height - 4 // rough estimate for header and footer space
        contentStr := content.String()

        // If content is shorter than available space, add padding
        lines := strings.Split(strings.TrimRight(contentStr, "\n"), "\n")
        if len(lines) &lt; contentHeight-2 </span><span class="cov0" title="0">{
                for len(lines) &lt; contentHeight-2 </span><span class="cov0" title="0">{
                        lines = append(lines, "")
                }</span>
                <span class="cov0" title="0">contentStr = strings.Join(lines, "\n")</span>
        }

        <span class="cov0" title="0">return header + "\n" + contentStr + "\n" + footer</span>
}

func (m Model) viewScanning() string <span class="cov0" title="0">{
        header := listHeaderStyle.Render("🔄 Scanne Stories")

        src := "(none)"
        tgt := "(none)"
        if m.sourceSpace != nil </span><span class="cov0" title="0">{
                src = fmt.Sprintf("%s (ID: %d)", m.sourceSpace.Name, m.sourceSpace.ID)
        }</span>
        <span class="cov0" title="0">if m.targetSpace != nil </span><span class="cov0" title="0">{
                tgt = fmt.Sprintf("%s (ID: %d)", m.targetSpace.Name, m.targetSpace.ID)
        }</span>

        <span class="cov0" title="0">content := fmt.Sprintf("%s %s\n\n", m.spinner.View(), subtitleStyle.Render("Lade Stories aus beiden Spaces..."))
        content += fmt.Sprintf("📂 Source: %s\n", okStyle.Render(src))
        content += fmt.Sprintf("📂 Target: %s\n", okStyle.Render(tgt))

        footer := renderFooter("", "⌨️  q: beenden")

        // Add padding to push footer to bottom
        contentHeight := m.height - 6 // space for header, content, and footer
        lines := strings.Split(strings.TrimRight(content, "\n"), "\n")
        for len(lines) &lt; contentHeight </span><span class="cov0" title="0">{
                lines = append(lines, "")
        }</span>
        <span class="cov0" title="0">paddedContent := strings.Join(lines, "\n")

        return header + "\n\n" + paddedContent + "\n" + footer</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package ui

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

func (m Model) renderSyncHeader() string <span class="cov0" title="0">{
        var b strings.Builder

        // Count states for progress information
        total := len(m.preflight.items)
        completed := 0
        running := 0
        cancelled := 0
        pending := 0

        for _, item := range m.preflight.items </span><span class="cov0" title="0">{
                switch item.Run </span>{
                case RunDone:<span class="cov0" title="0">
                        completed++</span>
                case RunRunning:<span class="cov0" title="0">
                        running++</span>
                case RunCancelled:<span class="cov0" title="0">
                        cancelled++</span>
                default:<span class="cov0" title="0"> // RunPending
                        pending++</span>
                }
        }

        // Progress information with detailed counts
        <span class="cov0" title="0">statusParts := []string{fmt.Sprintf("%d✓", completed)}
        if running &gt; 0 </span><span class="cov0" title="0">{
                statusParts = append(statusParts, fmt.Sprintf("%d◯", running))
        }</span>
        <span class="cov0" title="0">if cancelled &gt; 0 </span><span class="cov0" title="0">{
                statusParts = append(statusParts, fmt.Sprintf("%d✗", cancelled))
        }</span>
        <span class="cov0" title="0">if pending &gt; 0 </span><span class="cov0" title="0">{
                statusParts = append(statusParts, fmt.Sprintf("%d◦", pending))
        }</span>

        <span class="cov0" title="0">progressText := fmt.Sprintf("Synchronisierung (%s von %d)", strings.Join(statusParts, " "), total)
        b.WriteString(listHeaderStyle.Render(progressText))
        b.WriteString("\n")

        // Current item being processed - find the running item
        for i, item := range m.preflight.items </span><span class="cov0" title="0">{
                if item.Run == RunRunning </span><span class="cov0" title="0">{
                        itemText := fmt.Sprintf("Läuft: %s | %s (%s)", item.Story.Name, item.Story.FullSlug, item.State)
                        b.WriteString(warnStyle.Render(itemText))
                        break</span>
                } else<span class="cov0" title="0"> if i == m.syncIndex &amp;&amp; m.syncing &amp;&amp; item.Run == RunPending </span><span class="cov0" title="0">{
                        // Fallback to sync index if no running item found
                        itemText := fmt.Sprintf("Verarbeite: %s | %s (%s)", item.Story.Name, item.Story.FullSlug, item.State)
                        b.WriteString(subtleStyle.Render(itemText))
                        break</span>
                }
        }

        <span class="cov0" title="0">b.WriteString("\n")
        return b.String()</span>
}

func (m Model) renderSyncFooter() string <span class="cov0" title="0">{
        statusLine := ""
        if m.syncing </span><span class="cov0" title="0">{
                statusLine = m.spinner.View() + " Synchronisiere..."
        }</span>

        <span class="cov0" title="0">return renderFooter(statusLine, "ctrl+c: Abbrechen")</span>
}

func (m *Model) updateSyncViewport() <span class="cov0" title="0">{
        var content strings.Builder

        // Show sync progress
        total := len(m.preflight.items)
        completed := 0
        running := 0
        cancelled := 0

        // Count actual states from preflight items
        for _, item := range m.preflight.items </span><span class="cov0" title="0">{
                switch item.Run </span>{
                case RunDone:<span class="cov0" title="0">
                        completed++</span>
                case RunRunning:<span class="cov0" title="0">
                        running++</span>
                case RunCancelled:<span class="cov0" title="0">
                        cancelled++</span>
                }
        }

        // Progress bar
        <span class="cov0" title="0">progressBar := m.renderProgressBar(completed, cancelled, total)
        content.WriteString(progressBar)
        content.WriteString("\n\n")

        // Show all items with their current states
        maxDisplay := 20 // Show more items for better visibility
        startIdx := 0
        if len(m.preflight.items) &gt; maxDisplay </span><span class="cov0" title="0">{
                // Show items around the current sync position
                startIdx = m.syncIndex - maxDisplay/2
                if startIdx &lt; 0 </span><span class="cov0" title="0">{
                        startIdx = 0
                }</span>
                <span class="cov0" title="0">if startIdx+maxDisplay &gt; len(m.preflight.items) </span><span class="cov0" title="0">{
                        startIdx = len(m.preflight.items) - maxDisplay
                }</span>
        }

        <span class="cov0" title="0">endIdx := startIdx + maxDisplay
        if endIdx &gt; len(m.preflight.items) </span><span class="cov0" title="0">{
                endIdx = len(m.preflight.items)
        }</span>

        <span class="cov0" title="0">for i := startIdx; i &lt; endIdx; i++ </span><span class="cov0" title="0">{
                item := m.preflight.items[i]
                status, color := m.getItemStatusDisplay(item.Run)

                // Show sync action and current state
                actionText := string(item.State)
                if item.Run == RunRunning </span><span class="cov0" title="0">{
                        actionText += " (läuft...)"
                }</span>

                // Format: [status] Name | slug (action)
                <span class="cov0" title="0">line := fmt.Sprintf("%s %s | %s (%s)",
                        color.Render(status),
                        item.Story.Name,
                        subtleStyle.Render(item.Story.FullSlug),
                        subtleStyle.Render(actionText))
                content.WriteString(line)
                content.WriteString("\n")</span>
        }

        // Show summary if we're not displaying all items
        <span class="cov0" title="0">if len(m.preflight.items) &gt; maxDisplay </span><span class="cov0" title="0">{
                content.WriteString("\n")
                summaryText := fmt.Sprintf("... zeige %d-%d von %d Items",
                        startIdx+1, endIdx, len(m.preflight.items))
                content.WriteString(subtleStyle.Render(summaryText))
                content.WriteString("\n")
        }</span>

        <span class="cov0" title="0">m.viewport.SetContent(content.String())</span>
}

func (m Model) getItemStatusDisplay(runState RunState) (string, lipgloss.Style) <span class="cov0" title="0">{
        switch runState </span>{
        case RunDone:<span class="cov0" title="0">
                return "✓", okStyle</span>
        case RunRunning:<span class="cov0" title="0">
                return "◯", warnStyle</span>
        case RunCancelled:<span class="cov0" title="0">
                return "✗", errorStyle</span>
        default:<span class="cov0" title="0"> // RunPending
                return "◦", subtleStyle</span>
        }
}

func (m Model) renderProgressBar(completed, cancelled, total int) string <span class="cov0" title="0">{
        if total == 0 </span><span class="cov0" title="0">{
                return "Kein Fortschritt verfügbar"
        }</span>

        <span class="cov0" title="0">processed := completed + cancelled
        percentage := float64(processed) / float64(total) * 100
        barWidth := 50
        completedWidth := int(float64(barWidth) * float64(completed) / float64(total))
        cancelledWidth := int(float64(barWidth) * float64(cancelled) / float64(total))

        var bar strings.Builder
        bar.WriteString("[")

        // Completed portion (green)
        for i := 0; i &lt; completedWidth; i++ </span><span class="cov0" title="0">{
                bar.WriteString(okStyle.Render("█"))
        }</span>

        // Cancelled portion (red)
        <span class="cov0" title="0">for i := 0; i &lt; cancelledWidth; i++ </span><span class="cov0" title="0">{
                bar.WriteString(errorStyle.Render("█"))
        }</span>

        // Empty portion
        <span class="cov0" title="0">remaining := barWidth - completedWidth - cancelledWidth
        for i := 0; i &lt; remaining; i++ </span><span class="cov0" title="0">{
                bar.WriteString("░")
        }</span>

        <span class="cov0" title="0">bar.WriteString("]")

        // Status text
        statusParts := []string{fmt.Sprintf("%d✓", completed)}
        if cancelled &gt; 0 </span><span class="cov0" title="0">{
                statusParts = append(statusParts, fmt.Sprintf("%d✗", cancelled))
        }</span>
        <span class="cov0" title="0">statusText := strings.Join(statusParts, " ")

        progressText := fmt.Sprintf("%s %.1f%% (%s/%d)",
                bar.String(), percentage, statusText, total)

        return focusStyle.Render(progressText)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package ui

// ensureCursorInViewport adjusts the viewport Y offset so that the given
// absolute cursorLine is within the visible window with a scroll margin.
func (m *Model) ensureCursorInViewport(cursorLine int) <span class="cov8" title="1">{
        topLine := m.viewport.YOffset
        bottomLine := topLine + m.viewport.Height - 1

        scrollMargin := 3
        if m.viewport.Height &lt; 8 </span><span class="cov8" title="1">{
                scrollMargin = 1
        }</span>

        <span class="cov8" title="1">if cursorLine &lt; topLine+scrollMargin </span><span class="cov8" title="1">{
                target := cursorLine - scrollMargin
                if target &lt; 0 </span><span class="cov8" title="1">{
                        target = 0
                }</span>
                <span class="cov8" title="1">m.viewport.SetYOffset(target)
                return</span>
        }
        <span class="cov8" title="1">if cursorLine &gt; bottomLine-scrollMargin </span><span class="cov8" title="1">{
                target := cursorLine - m.viewport.Height + scrollMargin + 1
                if target &lt; 0 </span><span class="cov0" title="0">{
                        target = 0
                }</span>
                <span class="cov8" title="1">m.viewport.SetYOffset(target)</span>
        }
}

// countWrappedLines counts how many display lines a piece of styled content takes
// Currently we count explicit newlines; lipgloss Width padding does not add newlines.
func (m *Model) countWrappedLines(styledContent string) int <span class="cov8" title="1">{
        if styledContent == "" </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov8" title="1">lines := 1
        for _, ch := range styledContent </span><span class="cov8" title="1">{
                if ch == '\n' </span><span class="cov0" title="0">{
                        lines++
                }</span>
        }
        <span class="cov8" title="1">return lines</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package ui

import "storyblok-sync/internal/sb"

// visibleOrderBrowse returns visible stories for the browse view in order,
// and a copy of the underlying visibleIdx (mapping to storiesSource indices).
func (m *Model) visibleOrderBrowse() ([]sb.Story, []int) <span class="cov8" title="1">{
        total := m.itemsLen()
        if total &lt;= 0 </span><span class="cov0" title="0">{
                return []sb.Story{}, []int{}
        }</span>
        <span class="cov8" title="1">stories := make([]sb.Story, total)
        for i := 0; i &lt; total; i++ </span><span class="cov8" title="1">{
                stories[i] = m.itemAt(i)
        }</span>
        <span class="cov8" title="1">order := make([]int, len(m.visibleIdx))
        copy(order, m.visibleIdx)
        return stories, order</span>
}

// visibleOrderPreflight returns visible preflight stories and the order slice
// mapping visible positions to indices in m.preflight.items.
func (m *Model) visibleOrderPreflight() ([]sb.Story, []int) <span class="cov8" title="1">{
        n := len(m.preflight.items)
        if n == 0 </span><span class="cov0" title="0">{
                return []sb.Story{}, []int{}
        }</span>
        <span class="cov8" title="1">order := m.preflight.visibleIdx
        if len(order) == 0 </span><span class="cov8" title="1">{
                order = make([]int, n)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        order[i] = i
                }</span>
        } else<span class="cov8" title="1"> {
                dup := make([]int, len(order))
                copy(dup, order)
                order = dup
        }</span>
        <span class="cov8" title="1">stories := make([]sb.Story, len(order))
        for i, idx := range order </span><span class="cov8" title="1">{
                stories[i] = m.preflight.items[idx].Story
        }</span>
        <span class="cov8" title="1">return stories, order</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
